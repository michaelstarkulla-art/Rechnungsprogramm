<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rechnungsprogramm</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js"></script>
  <style>
    @media print {
      .no-print { display: none !important; }
      .print-only { display: inline !important; }
      body { background: white !important; margin: 0; }
      #rechnung-druck {
        box-shadow: none !important;
        background: white !important;
        margin: 0 !important;
        padding: 25mm 20mm 45mm 25mm !important;
      }
      .page-footer {
        position: fixed !important;
        bottom: 12mm !important;
        left: 25mm !important;
        right: 20mm !important;
        height: 28mm;
        margin: 0;
        padding: 0;
        font-size: 9pt;
        color: #444;
        z-index: 100;
        background: white;
        border-top: 1px solid #ccc;
      }
      .page-content {
        padding-bottom: 50mm;
      }
      tr { page-break-inside: avoid; }
    }

    .custom-scrollbar::-webkit-scrollbar { width: 4px; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #0d9488; border-radius: 10px; }
    textarea { overflow: hidden; resize: none; min-height: 1.5rem; }
    .print-only { display: none; }
    
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * START-MODAL - Datenschutzhinweis beim ersten Laden
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .start-modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(6px);
      z-index: 999999; display: flex; align-items: center; justify-content: center;
      padding: 16px; opacity: 1; transition: opacity 0.3s ease;
    }
    .start-modal-overlay.hidden { opacity: 0; pointer-events: none; display: none !important; }
    .start-modal {
      background: linear-gradient(145deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 16px; max-width: 420px; width: 100%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(13, 148, 136, 0.3); overflow: hidden;
      animation: modalSlideIn 0.3s ease;
      max-height: 90vh;
      overflow-y: auto;
    }
    @keyframes modalSlideIn {
      from { transform: translateY(-20px) scale(0.97); opacity: 0; }
      to { transform: translateY(0) scale(1); opacity: 1; }
    }
    .start-modal-header {
      padding: 20px 24px 16px; text-align: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }
    .start-modal-header .shield-icon { font-size: 2rem; margin-bottom: 8px; }
    .start-modal-motto { margin-bottom: 10px; }
    .start-modal-motto p { color: #2dd4bf; font-size: 1rem; font-weight: 700; margin: 0; letter-spacing: 0.5px; }
    .start-modal-header h2 { color: #94a3b8; margin: 0; font-size: 0.85rem; font-weight: 500; }
    .start-modal-body { padding: 20px 24px; color: #e2e8f0; }
    .start-modal-intro { color: #94a3b8; font-size: 0.8rem; margin-bottom: 14px; line-height: 1.5; }
    .info-item {
      display: flex; gap: 10px; margin-bottom: 10px; padding: 10px;
      background: rgba(255, 255, 255, 0.02); border-radius: 6px;
      border-left: 2px solid rgba(255, 255, 255, 0.15);
    }
    .info-item.warning { border-left-color: rgba(245, 158, 11, 0.5); }
    .info-item.danger { border-left-color: rgba(239, 68, 68, 0.5); }
    .info-item.success { border-left-color: rgba(34, 197, 94, 0.5); }
    .info-item .icon { font-size: 1rem; flex-shrink: 0; opacity: 0.8; }
    .info-item .text { flex: 1; }
    .info-item .text strong { color: #cbd5e1; display: block; margin-bottom: 2px; font-size: 0.75rem; }
    .info-item .text span { color: #64748b; font-size: 0.7rem; line-height: 1.4; }
    .start-modal-features { margin-top: 14px; padding-top: 14px; border-top: 1px solid rgba(255, 255, 255, 0.06); }
    .feature-badges { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
    .feature-badge {
      background: rgba(13, 148, 136, 0.15); color: #2dd4bf;
      padding: 4px 8px; border-radius: 12px; font-size: 0.65rem; font-weight: 500;
      border: 1px solid rgba(13, 148, 136, 0.3);
    }
    .start-modal-footer { padding: 16px 24px 20px; text-align: center; }
    .start-modal-footer button {
      width: 100%; padding: 12px 24px; font-size: 0.85rem; font-weight: 600;
      background: linear-gradient(135deg, #0d9488 0%, #0f766e 100%);
      color: white; border: none; border-radius: 8px; cursor: pointer;
      transition: all 0.2s ease; box-shadow: 0 2px 12px rgba(13, 148, 136, 0.25);
    }
    .start-modal-footer button:hover { transform: translateY(-1px); box-shadow: 0 4px 16px rgba(13, 148, 136, 0.35); }
    .start-modal-footer small { display: block; margin-top: 10px; color: #475569; font-size: 0.65rem; }

    /* Privacy Footer */
    .privacy-footer {
      margin-top: 2rem; padding: 1.5rem;
      background: linear-gradient(145deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 12px; border: 1px solid rgba(13, 148, 136, 0.2); text-align: center;
    }
    .privacy-footer-motto { font-size: 0.95rem; font-weight: 700; color: #2dd4bf; margin-bottom: 12px; letter-spacing: 0.5px; }
    .privacy-footer-motto .shield { font-size: 1.1rem; margin-right: 6px; }
    .privacy-footer-text { color: #94a3b8; font-size: 0.8rem; line-height: 1.6; max-width: 600px; margin: 0 auto 16px; }
    .privacy-footer-badges { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 12px; }
    .privacy-badge {
      display: inline-flex; align-items: center; gap: 4px;
      background: rgba(13, 148, 136, 0.1); color: #5eead4;
      padding: 6px 10px; border-radius: 16px; font-size: 0.7rem; font-weight: 500;
      border: 1px solid rgba(13, 148, 136, 0.2);
    }
    .privacy-badge.green { background: rgba(34, 197, 94, 0.1); color: #4ade80; border-color: rgba(34, 197, 94, 0.2); }
    .privacy-footer-copyright { margin-top: 16px; padding-top: 12px; border-top: 1px solid rgba(255, 255, 255, 0.08); color: #64748b; font-size: 0.65rem; }
    
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * MOBILE-FIRST RESPONSIVE LAYOUT
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    /* Sidebar - Standard: Versteckt auf Mobile */
    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      height: 100vh;
      z-index: 45;
      transform: translateX(-100%);
      transition: transform 0.3s ease-in-out;
      overflow-y: auto;
    }
    
    .sidebar.open {
      transform: translateX(0);
    }
    
    .sidebar-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 44;
      backdrop-filter: blur(2px);
    }
    
    .sidebar-backdrop.open {
      display: block;
    }
    
    .main-content {
      width: 100%;
    }
    
    /* Desktop: Sidebar sichtbar */
    @media (min-width: 768px) {
      .sidebar {
        position: relative;
        transform: translateX(0);
        z-index: 1;
        width: 24rem; /* w-96 */
        flex-shrink: 0;
      }
      
      .sidebar-backdrop {
        display: none !important;
      }
      
      .main-content {
        flex: 1;
      }
    }
    
    /* Cloud-Sync Spinner Animation */
    @keyframes cloud-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .animate-cloud-spin {
      animation: cloud-spin 1s linear infinite;
    }
  </style>
</head>
<body class="bg-slate-100 font-sans antialiased">

<!-- Start-Modal - Datenschutz & Sicherheitshinweis -->
<div id="start-modal-overlay" class="start-modal-overlay">
  <div class="start-modal">
    <div class="start-modal-header">
      <div class="shield-icon">ğŸ›¡ï¸</div>
      <div class="start-modal-motto">
        <p>Wir speichern nichts. Wir sehen nichts.</p>
      </div>
      <h2>Lokale Browser-Anwendung Â· Rechnungsprogramm</h2>
    </div>
    <div class="start-modal-body">
      <p class="start-modal-intro">
        Deine Daten werden lokal in deinem Browser gespeichert (IndexedDB) â€“ niemals auf externen Servern.
      </p>
      <div class="info-item success">
        <span class="icon">ğŸ’¾</span>
        <div class="text">
          <strong>Lokale Speicherung</strong>
          <span>Deine Daten bleiben auch nach dem SchlieÃŸen des Browsers erhalten. Aber: Bei Browser-LÃ¶schung oder GerÃ¤tewechsel gehen sie verloren!</span>
        </div>
      </div>
      <div class="info-item warning">
        <span class="icon">ğŸ“¤</span>
        <div class="text">
          <strong>RegelmÃ¤ÃŸige Backups</strong>
          <span>Erstelle regelmÃ¤ÃŸig verschlÃ¼sselte Backups, um deine Daten zu sichern und auf andere GerÃ¤te zu Ã¼bertragen.</span>
        </div>
      </div>
      <div class="info-item danger">
        <span class="icon">ğŸ”‘</span>
        <div class="text">
          <strong>Passwort</strong>
          <span>Es gibt keine Wiederherstellung. Ohne Passwort ist dein Backup wertlos â€“ merke es dir gut!</span>
        </div>
      </div>
      <div class="info-item">
        <span class="icon">âš–ï¸</span>
        <div class="text">
          <strong>Haftung</strong>
          <span>Nutzung auf eigene Verantwortung. Keine Haftung fÃ¼r Datenverlust oder SchÃ¤den.</span>
        </div>
      </div>
      <div class="start-modal-features">
        <div class="feature-badges">
          <span class="feature-badge">ğŸ”’ AES-256-GCM</span>
          <span class="feature-badge">ğŸš« Keine Server</span>
          <span class="feature-badge">ğŸ’¾ 5MB Fixed-Size</span>
          <span class="feature-badge">ğŸ‘ï¸ Zero-Knowledge</span>
          <span class="feature-badge">ğŸ”§ Web Worker</span>
        </div>
      </div>
    </div>
    <div class="start-modal-footer">
      <button onclick="closeStartModal()">âœ“ Ich habe alles verstanden</button>
      <small>Deine Zustimmung wird lokal fÃ¼r diese Sitzung gespeichert</small>
    </div>
  </div>
</div>

<script>
function closeStartModal() {
  const overlay = document.getElementById('start-modal-overlay');
  overlay.classList.add('hidden');
  setTimeout(() => { overlay.style.display = 'none'; }, 300);
  sessionStorage.setItem('rechnungsprogrammfast_modal_accepted', 'true');
}
// Nur verstecken wenn User explizit akzeptiert hat
if (sessionStorage.getItem('rechnungsprogrammfast_modal_accepted') === 'true') {
  document.getElementById('start-modal-overlay').style.display = 'none';
}
</script>

<div id="root"></div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HIGH-SECURITY VAULT - Single-Blob mit Privacy Padding
// AES-256-GCM + Web Worker + 5MB Privacy-Preserving Architecture
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const VAULT_CONFIG = {
  algorithm: 'AES-GCM',
  keyLength: 256,
  ivLength: 12,
  saltLength: 16,
  iterations: 310000, // OWASP 2023 Empfehlung
  tagLength: 128,
  FIXED_SIZE: 5 * 1024 * 1024, // 5 MB Fixed-Size zur Verschleierung der tatsÃ¤chlichen Datenmenge (Privacy Padding)
  DB_NAME: 'SecureVaultDB',
  STORE_NAME: 'secure_vault',
  KEY_NAME: 'current_state',
  DEBOUNCE_MS: 2000 // 2 Sekunden Debounce
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEB WORKER (Inline als Blob-URL) - VerschlÃ¼sselung im Hintergrund
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const workerCode = `
// Worker fÃ¼r rechenintensive VerschlÃ¼sselung
const VAULT_CONFIG = {
  algorithm: 'AES-GCM',
  keyLength: 256,
  ivLength: 12,
  saltLength: 16,
  iterations: 310000,
  tagLength: 128,
  FIXED_SIZE: 5 * 1024 * 1024,
  MAX_RANDOM_CHUNK: 65536 // crypto.getRandomValues() Limit
};

function generateRandomBytes(length) {
  // FÃ¼r kleine LÃ¤ngen direkt generieren
  if (length <= VAULT_CONFIG.MAX_RANDOM_CHUNK) {
    return crypto.getRandomValues(new Uint8Array(length));
  }
  
  // FÃ¼r groÃŸe LÃ¤ngen in Chunks aufteilen
  const result = new Uint8Array(length);
  let offset = 0;
  while (offset < length) {
    const chunkSize = Math.min(VAULT_CONFIG.MAX_RANDOM_CHUNK, length - offset);
    const chunk = crypto.getRandomValues(new Uint8Array(chunkSize));
    result.set(chunk, offset);
    offset += chunkSize;
  }
  return result;
}

async function deriveKey(password, salt) {
  const encoder = new TextEncoder();
  const passwordBuffer = encoder.encode(password);
  const baseKey = await crypto.subtle.importKey('raw', passwordBuffer, 'PBKDF2', false, ['deriveKey']);
  return await crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt: salt, iterations: VAULT_CONFIG.iterations, hash: 'SHA-256' },
    baseKey,
    { name: VAULT_CONFIG.algorithm, length: VAULT_CONFIG.keyLength },
    true, ['encrypt', 'decrypt']
  );
}

// Fixed-Size Padding: FÃ¼gt kryptografisches Rauschen hinzu bis exakt 5MB erreicht sind
function padToFixedSize(dataBuffer, targetSize) {
  const dataLength = dataBuffer.byteLength;
  // 4 Bytes fÃ¼r LÃ¤ngenfeld + Daten + Padding
  const paddingNeeded = targetSize - 4 - dataLength;
  
  if (paddingNeeded < 0) {
    throw new Error('Daten zu groÃŸ fÃ¼r Fixed-Size Container (' + dataLength + ' Bytes > ' + (targetSize - 4) + ' max)');
  }
  
  const result = new Uint8Array(targetSize);
  const view = new DataView(result.buffer);
  
  // Erste 4 Bytes: tatsÃ¤chliche DatenlÃ¤nge (Big-Endian)
  view.setUint32(0, dataLength, false);
  
  // Daten kopieren
  result.set(new Uint8Array(dataBuffer), 4);
  
  // Rest mit kryptografischem Zufallsrauschen fÃ¼llen (in Chunks)
  const padding = generateRandomBytes(paddingNeeded);
  result.set(padding, 4 + dataLength);
  
  return result;
}

// Fixed-Size Unpadding: Extrahiert die echten Daten aus dem 5MB Block
function unpadFromFixedSize(paddedBuffer) {
  const view = new DataView(paddedBuffer);
  const dataLength = view.getUint32(0, false);
  
  if (dataLength > paddedBuffer.byteLength - 4) {
    throw new Error('UngÃ¼ltige DatenlÃ¤nge im Header');
  }
  
  return paddedBuffer.slice(4, 4 + dataLength);
}

// VerschlÃ¼sselung mit Fixed-Size Padding
async function encryptWithPadding(data, password, useFixedSize = true) {
  const jsonString = JSON.stringify(data);
  const encoder = new TextEncoder();
  let dataBuffer = encoder.encode(jsonString);
  
  // Fixed-Size Padding anwenden wenn gewÃ¼nscht
  if (useFixedSize) {
    dataBuffer = padToFixedSize(dataBuffer, VAULT_CONFIG.FIXED_SIZE - VAULT_CONFIG.saltLength - VAULT_CONFIG.ivLength - 16);
  }
  
  const salt = generateRandomBytes(VAULT_CONFIG.saltLength);
  const iv = generateRandomBytes(VAULT_CONFIG.ivLength);
  const key = await deriveKey(password, salt);
  
  const encryptedData = await crypto.subtle.encrypt(
    { name: VAULT_CONFIG.algorithm, iv: iv, tagLength: VAULT_CONFIG.tagLength },
    key, dataBuffer
  );
  
  const result = new Uint8Array(VAULT_CONFIG.saltLength + VAULT_CONFIG.ivLength + encryptedData.byteLength);
  result.set(salt, 0);
  result.set(iv, VAULT_CONFIG.saltLength);
  result.set(new Uint8Array(encryptedData), VAULT_CONFIG.saltLength + VAULT_CONFIG.ivLength);
  
  return result.buffer;
}

// EntschlÃ¼sselung mit Fixed-Size Unpadding
async function decryptWithPadding(encryptedBuffer, password, useFixedSize = true) {
  const encryptedArray = new Uint8Array(encryptedBuffer);
  const salt = encryptedArray.slice(0, VAULT_CONFIG.saltLength);
  const iv = encryptedArray.slice(VAULT_CONFIG.saltLength, VAULT_CONFIG.saltLength + VAULT_CONFIG.ivLength);
  const ciphertext = encryptedArray.slice(VAULT_CONFIG.saltLength + VAULT_CONFIG.ivLength);
  
  const key = await deriveKey(password, salt);
  
  let decryptedBuffer = await crypto.subtle.decrypt(
    { name: VAULT_CONFIG.algorithm, iv: iv, tagLength: VAULT_CONFIG.tagLength },
    key, ciphertext
  );
  
  // Fixed-Size Unpadding wenn gewÃ¼nscht
  if (useFixedSize) {
    decryptedBuffer = unpadFromFixedSize(decryptedBuffer);
  }
  
  const decoder = new TextDecoder();
  return JSON.parse(decoder.decode(decryptedBuffer));
}

// Worker Message Handler
self.onmessage = async (e) => {
  const { type, data, password, useFixedSize, id } = e.data;
  
  try {
    if (type === 'encrypt') {
      const encrypted = await encryptWithPadding(data, password, useFixedSize);
      self.postMessage({ type: 'encrypted', data: encrypted, id, success: true });
    } else if (type === 'decrypt') {
      const decrypted = await decryptWithPadding(data, password, useFixedSize);
      self.postMessage({ type: 'decrypted', data: decrypted, id, success: true });
    }
  } catch (error) {
    self.postMessage({ type: 'error', error: error.message, id, success: false });
  }
};
`;

// Worker als Blob-URL erstellen (funktioniert lokal ohne Server)
const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
const workerUrl = URL.createObjectURL(workerBlob);
let cryptoWorker = null;
let workerCallbacks = new Map();
let workerIdCounter = 0;

function getCryptoWorker() {
  if (!cryptoWorker) {
    console.log('ğŸ”§ Initialisiere Crypto-Worker...');
    cryptoWorker = new Worker(workerUrl);
    cryptoWorker.onmessage = (e) => {
      const { id, success, data, error, type } = e.data;
      console.log('ğŸ“¬ Worker-Nachricht empfangen:', { id, success, type });
      const callback = workerCallbacks.get(id);
      if (callback) {
        workerCallbacks.delete(id);
        if (success) {
          callback.resolve(data);
        } else {
          callback.reject(new Error(error));
        }
      } else {
        console.warn('âš ï¸ Kein Callback fÃ¼r Worker-ID:', id);
      }
    };
    cryptoWorker.onerror = (e) => {
      console.error('âŒ Worker Error:', e);
      // Bei Worker-Fehler alle wartenden Callbacks ablehnen
      for (const [id, callback] of workerCallbacks) {
        callback.reject(new Error('Worker-Fehler: ' + e.message));
      }
      workerCallbacks.clear();
    };
    console.log('âœ“ Crypto-Worker initialisiert');
  }
  return cryptoWorker;
}

// Promise-basierte Worker-Kommunikation
function workerEncrypt(data, password, useFixedSize = true) {
  return new Promise((resolve, reject) => {
    console.log('â³ Worker-VerschlÃ¼sselung gestartet...');
    const id = ++workerIdCounter;
    workerCallbacks.set(id, { 
      resolve: (result) => {
        console.log('âœ“ Worker-VerschlÃ¼sselung erfolgreich');
        resolve(result);
      }, 
      reject: (err) => {
        console.error('âœ— Worker-VerschlÃ¼sselung fehlgeschlagen:', err);
        reject(err);
      }
    });
    getCryptoWorker().postMessage({ type: 'encrypt', data, password, useFixedSize, id });
  });
}

function workerDecrypt(data, password, useFixedSize = true) {
  return new Promise((resolve, reject) => {
    console.log('â³ Worker-EntschlÃ¼sselung gestartet...');
    const id = ++workerIdCounter;
    workerCallbacks.set(id, { 
      resolve: (result) => {
        console.log('âœ“ Worker-EntschlÃ¼sselung erfolgreich');
        resolve(result);
      }, 
      reject: (err) => {
        console.error('âœ— Worker-EntschlÃ¼sselung fehlgeschlagen:', err);
        reject(err);
      }
    });
    getCryptoWorker().postMessage({ type: 'decrypt', data, password, useFixedSize, id });
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECURE VAULT - Single-Blob IndexedDB Architektur
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const SecureVault = {
  db: null,
  encryptionKey: null, // Wird im RAM gehalten, NIEMALS persistiert
  
  async openDB() {
    if (this.db) return this.db;
    
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(VAULT_CONFIG.DB_NAME, 1);
      req.onerror = () => reject(req.error);
      req.onsuccess = () => {
        this.db = req.result;
        resolve(this.db);
      };
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        // Nur ein einziger Store fÃ¼r den verschlÃ¼sselten Blob
        if (!db.objectStoreNames.contains(VAULT_CONFIG.STORE_NAME)) {
          db.createObjectStore(VAULT_CONFIG.STORE_NAME);
        }
      };
    });
  },
  
  // PrÃ¼ft ob bereits Daten existieren
  async hasData() {
    const db = await this.openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(VAULT_CONFIG.STORE_NAME, 'readonly');
      const store = tx.objectStore(VAULT_CONFIG.STORE_NAME);
      const req = store.get(VAULT_CONFIG.KEY_NAME);
      req.onsuccess = () => resolve(req.result !== undefined);
      req.onerror = () => reject(req.error);
    });
  },
  
  // LÃ¤dt und entschlÃ¼sselt den Vault
  async load(password) {
    const db = await this.openDB();
    
    return new Promise(async (resolve, reject) => {
      const tx = db.transaction(VAULT_CONFIG.STORE_NAME, 'readonly');
      const store = tx.objectStore(VAULT_CONFIG.STORE_NAME);
      const req = store.get(VAULT_CONFIG.KEY_NAME);
      
      req.onsuccess = async () => {
        if (!req.result) {
          // Keine Daten vorhanden - leeren State zurÃ¼ckgeben
          this.encryptionKey = password;
          resolve(null);
          return;
        }
        
        try {
          const decrypted = await workerDecrypt(req.result, password, true);
          this.encryptionKey = password;
          resolve(decrypted);
        } catch (err) {
          reject(new Error('Falsches Passwort oder beschÃ¤digte Daten'));
        }
      };
      req.onerror = () => reject(req.error);
    });
  },
  
  // VerschlÃ¼sselt und speichert den Vault (Full Overwrite)
  async save(data) {
    if (!this.encryptionKey) {
      throw new Error('Vault nicht entsperrt');
    }
    
    const db = await this.openDB();
    const encrypted = await workerEncrypt(data, this.encryptionKey, true);
    
    // PrÃ¼fe dass die GrÃ¶ÃŸe exakt 5MB ist
    console.log('Vault-GrÃ¶ÃŸe:', encrypted.byteLength, 'Bytes (erwartet:', VAULT_CONFIG.FIXED_SIZE, ')');
    
    return new Promise((resolve, reject) => {
      const tx = db.transaction(VAULT_CONFIG.STORE_NAME, 'readwrite');
      const store = tx.objectStore(VAULT_CONFIG.STORE_NAME);
      const req = store.put(encrypted, VAULT_CONFIG.KEY_NAME);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  },
  
  // Initialisiert einen neuen Vault mit Passwort
  async initialize(password, initialData) {
    try {
      // Erst Datenbank Ã¶ffnen
      await this.openDB();
      // Dann Key setzen
      this.encryptionKey = password;
      // Dann speichern
      await this.save(initialData);
      console.log('âœ“ Vault erfolgreich initialisiert');
    } catch (err) {
      console.error('Vault-Initialisierung fehlgeschlagen:', err);
      this.encryptionKey = null;
      throw err;
    }
  },
  
  // PANIK-BUTTON: LÃ¶scht den Key aus dem RAM
  emergencyWipe() {
    if (this.encryptionKey) {
      // Ãœberschreibe den Key im Speicher
      this.encryptionKey = crypto.getRandomValues(new Uint8Array(64)).toString();
      this.encryptionKey = null;
    }
    // Worker terminieren
    if (cryptoWorker) {
      cryptoWorker.terminate();
      cryptoWorker = null;
    }
    workerCallbacks.clear();
    console.log('ğŸš¨ NOTFALL-WIPE: Encryption Key aus RAM gelÃ¶scht');
    return true;
  },
  
  // Ã„ndert das Passwort
  async changePassword(currentPassword, newPassword, data) {
    // Verifiziere altes Passwort
    if (currentPassword !== this.encryptionKey) {
      throw new Error('Aktuelles Passwort falsch');
    }
    this.encryptionKey = newPassword;
    await this.save(data);
  },
  
  // LÃ¶scht die gesamte Datenbank
  async destroyVault() {
    this.emergencyWipe();
    return new Promise((resolve, reject) => {
      const req = indexedDB.deleteDatabase(VAULT_CONFIG.DB_NAME);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEGACY ENCRYPTION (fÃ¼r Backup-Export ohne Fixed-Size)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CRYPTO_CONFIG = {
  algorithm: 'AES-GCM',
  keyLength: 256,
  ivLength: 12,
  saltLength: 16,
  iterations: 310000,
  tagLength: 128
};

function generateRandomBytes(length) {
  return crypto.getRandomValues(new Uint8Array(length));
}

async function deriveKey(password, salt) {
  const encoder = new TextEncoder();
  const passwordBuffer = encoder.encode(password);
  const baseKey = await crypto.subtle.importKey('raw', passwordBuffer, 'PBKDF2', false, ['deriveKey']);
  return await crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt: salt, iterations: CRYPTO_CONFIG.iterations, hash: 'SHA-256' },
    baseKey,
    { name: CRYPTO_CONFIG.algorithm, length: CRYPTO_CONFIG.keyLength },
    false, ['encrypt', 'decrypt']
  );
}

// Normale VerschlÃ¼sselung (ohne Fixed-Size, fÃ¼r Backup-Export)
async function encryptData(data, password) {
  const jsonString = JSON.stringify(data);
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(jsonString);
  const salt = generateRandomBytes(CRYPTO_CONFIG.saltLength);
  const iv = generateRandomBytes(CRYPTO_CONFIG.ivLength);
  const key = await deriveKey(password, salt);
  const encryptedData = await crypto.subtle.encrypt(
    { name: CRYPTO_CONFIG.algorithm, iv: iv, tagLength: CRYPTO_CONFIG.tagLength },
    key, dataBuffer
  );
  const result = new Uint8Array(CRYPTO_CONFIG.saltLength + CRYPTO_CONFIG.ivLength + encryptedData.byteLength);
  result.set(salt, 0);
  result.set(iv, CRYPTO_CONFIG.saltLength);
  result.set(new Uint8Array(encryptedData), CRYPTO_CONFIG.saltLength + CRYPTO_CONFIG.ivLength);
  return result.buffer;
}

async function decryptData(encryptedBuffer, password) {
  const encryptedArray = new Uint8Array(encryptedBuffer);
  const salt = encryptedArray.slice(0, CRYPTO_CONFIG.saltLength);
  const iv = encryptedArray.slice(CRYPTO_CONFIG.saltLength, CRYPTO_CONFIG.saltLength + CRYPTO_CONFIG.ivLength);
  const ciphertext = encryptedArray.slice(CRYPTO_CONFIG.saltLength + CRYPTO_CONFIG.ivLength);
  const key = await deriveKey(password, salt);
  const decryptedBuffer = await crypto.subtle.decrypt(
    { name: CRYPTO_CONFIG.algorithm, iv: iv, tagLength: CRYPTO_CONFIG.tagLength },
    key, ciphertext
  );
  const decoder = new TextDecoder();
  return JSON.parse(decoder.decode(decryptedBuffer));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LADE-DIALOG FÃœR LANGE OPERATIONEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showLoadingDialog(message = 'Verarbeite...') {
  const overlay = document.createElement('div');
  overlay.className = 'loading-overlay';
  overlay.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.85); display: flex; align-items: center;
    justify-content: center; z-index: 999999; flex-direction: column;
  `;
  overlay.innerHTML = `
    <div style="text-align: center; color: white;">
      <div style="font-size: 48px; margin-bottom: 20px; animation: spin 1s linear infinite;">âš™ï¸</div>
      <p style="font-size: 18px; font-weight: 600; margin: 0 0 10px 0;" id="loading-message">${message}</p>
      <p style="font-size: 12px; color: #94a3b8; margin: 0;">Dies kann einige Sekunden dauern...</p>
      <div style="margin-top: 20px; width: 200px; height: 4px; background: #334155; border-radius: 2px; overflow: hidden;">
        <div style="width: 30%; height: 100%; background: linear-gradient(90deg, #0d9488, #10b981); animation: loading-bar 1.5s ease-in-out infinite;"></div>
      </div>
    </div>
    <style>
      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
      @keyframes loading-bar { 0% { transform: translateX(-100%); } 100% { transform: translateX(400%); } }
    </style>
  `;
  document.body.appendChild(overlay);
  
  return {
    updateMessage: (msg) => {
      const el = document.getElementById('loading-message');
      if (el) el.textContent = msg;
    },
    close: () => overlay.remove()
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// XSS-SCHUTZ: Sanitize Text-Input
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function sanitizeText(text) {
  if (typeof text !== 'string') return '';
  return text
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;')
    .replace(/javascript:/gi, '')
    .replace(/on\w+=/gi, '')
    .trim();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CSV-IMPORT: Parser fÃ¼r externe Tools
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function parseCSV(csvText) {
  // Automatische Trennzeichen-Erkennung
  const firstLine = csvText.split('\n')[0] || '';
  const delimiter = firstLine.includes(';') ? ';' : ',';
  
  const lines = csvText.trim().split('\n');
  if (lines.length < 2) return { headers: [], rows: [] };
  
  // Header parsen
  const headers = lines[0].split(delimiter).map(h => 
    sanitizeText(h.replace(/^["']|["']$/g, '').trim().toLowerCase())
  );
  
  // Datenzeilen parsen
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    
    // Einfaches CSV-Parsing (berÃ¼cksichtigt AnfÃ¼hrungszeichen)
    const values = [];
    let current = '';
    let inQuotes = false;
    
    for (let j = 0; j < line.length; j++) {
      const char = line[j];
      if (char === '"' || char === "'") {
        inQuotes = !inQuotes;
      } else if (char === delimiter && !inQuotes) {
        values.push(sanitizeText(current.trim()));
        current = '';
      } else {
        current += char;
      }
    }
    values.push(sanitizeText(current.trim()));
    
    if (values.some(v => v)) {
      const row = {};
      headers.forEach((h, idx) => {
        row[h] = values[idx] || '';
      });
      rows.push(row);
    }
  }
  
  return { headers, rows, delimiter };
}

function detectCSVType(headers) {
  const headerStr = headers.join(' ').toLowerCase();
  
  // Kunden-Keywords
  const kundenKeywords = ['kunde', 'customer', 'firma', 'company', 'anrede', 'nachname', 'vorname', 'kundennummer', 'kunden nr', 'anschrift'];
  const isKunden = kundenKeywords.some(k => headerStr.includes(k));
  
  // Material-Keywords
  const materialKeywords = ['artikel', 'product', 'material', 'preis', 'price', 'vk', 'ek', 'einheit', 'unit', 'beschreibung', 'artikelnummer'];
  const isMaterial = materialKeywords.some(k => headerStr.includes(k));
  
  // Rechnungs-Keywords
  const rechnungsKeywords = ['rechnung', 'invoice', 'beleg', 'rechnungsnummer'];
  const isRechnung = rechnungsKeywords.some(k => headerStr.includes(k));
  
  if (isKunden && !isMaterial) return 'kunden';
  if (isMaterial && !isKunden) return 'material';
  if (isRechnung) return 'rechnungen';
  
  // Fallback: Wenn "preis" vorkommt, ist es Material
  if (headerStr.includes('preis') || headerStr.includes('price')) return 'material';
  
  return 'unknown';
}

function mapCSVToKunden(rows, headers) {
  // Spalten-Mapping fÃ¼r gÃ¤ngige Formate
  const nameFields = ['name', 'firma', 'company', 'organisation', 'nachname', 'kunde'];
  const vornameFields = ['vorname', 'first name', 'firstname'];
  const strasseFields = ['strasse', 'straÃŸe', 'address', 'anschrift', 'str'];
  const plzFields = ['plz', 'postleitzahl', 'zip', 'postal'];
  const ortFields = ['ort', 'stadt', 'city', 'wohnort'];
  const anredeFields = ['anrede', 'title', 'salutation'];
  const emailFields = ['email', 'e-mail', 'mail'];
  const telefonFields = ['telefon', 'phone', 'tel', 'fon'];
  
  const findField = (row, fields) => {
    for (const f of fields) {
      const key = Object.keys(row).find(k => k.includes(f));
      if (key && row[key]) return row[key];
    }
    return '';
  };
  
  return rows.map((row, idx) => {
    const vorname = findField(row, vornameFields);
    const nachname = findField(row, nameFields);
    const name = vorname ? `${vorname} ${nachname}`.trim() : nachname;
    
    return {
      id: Date.now() + idx,
      anrede: findField(row, anredeFields) || 'Organisation',
      name: sanitizeText(name),
      strasse: sanitizeText(findField(row, strasseFields)),
      plz: sanitizeText(findField(row, plzFields)),
      ort: sanitizeText(findField(row, ortFields)),
      email: sanitizeText(findField(row, emailFields)),
      telefon: sanitizeText(findField(row, telefonFields))
    };
  }).filter(k => k.name);
}

function mapCSVToMaterial(rows, headers) {
  // Spalten-Mapping fÃ¼r gÃ¤ngige Formate
  const nameFields = ['name', 'bezeichnung', 'beschreibung', 'artikel', 'product', 'artikelname'];
  const preisFields = ['preis', 'price', 'vk', 'verkaufspreis', 'bruttopreis', 'nettopreis', 'einzelpreis'];
  const einheitFields = ['einheit', 'unit', 'me', 'mengeneinheit'];
  const nummerFields = ['nummer', 'artikelnummer', 'art.nr', 'artnr', 'id'];
  
  const findField = (row, fields) => {
    for (const f of fields) {
      const key = Object.keys(row).find(k => k.includes(f));
      if (key && row[key]) return row[key];
    }
    return '';
  };
  
  return rows.map((row, idx) => {
    let preis = findField(row, preisFields);
    // Preis-Format normalisieren (12.50 oder 12,50 -> "12,50")
    if (preis) {
      preis = preis.toString().replace('.', ',').replace(/[^0-9,]/g, '');
      if (!preis.includes(',')) preis += ',00';
    }
    
    return {
      id: Date.now() + idx,
      name: sanitizeText(findField(row, nameFields)),
      einheit: sanitizeText(findField(row, einheitFields)) || 'Stk',
      preis: preis || '0,00'
    };
  }).filter(m => m.name);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HIGH-SECURITY 5MB FIXED-SIZE EXPORT (Base64 fÃ¼r Android-KompatibilitÃ¤t)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Neutrale Dateinamen zum Schutz der PrivatsphÃ¤re (.txt fÃ¼r Android Share)
function getRandomNeutralFilename() {
  const timestamp = Date.now().toString(36); // Kompakter Zeitstempel
  const prefixes = ['system_log', 'app_cache', 'debug_dump', 'config_data', 'user_prefs', 'storage_log'];
  const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
  return `${prefix}_${timestamp}.txt`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZUGFeRD XML GENERATOR (EN 16931 BASIC Profil) - NUR IM RAM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function generateZUGFeRDXML(dok, firmenDaten) {
  // ISO-Datum Format
  const now = new Date();
  const isoDate = now.toISOString().split('T')[0].replace(/-/g, '');
  const isAngebot = dok.typ === 'ANGEBOT';
  
  // Berechne Summen
  let nettoGesamt = 0;
  let mwstGesamt = 0;
  
  const positionen = (dok.positionen || []).map((pos, idx) => {
    const menge = parseFloat(String(pos.menge || 0).replace(',', '.')) || 0;
    const preis = parseFloat(String(pos.preis || 0).replace(',', '.')) || 0;
    const netto = menge * preis;
    const mwst = netto * 0.19;
    nettoGesamt += netto;
    mwstGesamt += mwst;
    
    return `
      <ram:IncludedSupplyChainTradeLineItem>
        <ram:AssociatedDocumentLineDocument>
          <ram:LineID>${idx + 1}</ram:LineID>
        </ram:AssociatedDocumentLineDocument>
        <ram:SpecifiedTradeProduct>
          <ram:Name>${escapeXML(pos.name || 'Position')}</ram:Name>
        </ram:SpecifiedTradeProduct>
        <ram:SpecifiedLineTradeAgreement>
          <ram:NetPriceProductTradePrice>
            <ram:ChargeAmount>${preis.toFixed(2)}</ram:ChargeAmount>
          </ram:NetPriceProductTradePrice>
        </ram:SpecifiedLineTradeAgreement>
        <ram:SpecifiedLineTradeDelivery>
          <ram:BilledQuantity unitCode="${escapeXML(pos.einheit || 'C62')}">${menge.toFixed(2)}</ram:BilledQuantity>
        </ram:SpecifiedLineTradeDelivery>
        <ram:SpecifiedLineTradeSettlement>
          <ram:ApplicableTradeTax>
            <ram:TypeCode>VAT</ram:TypeCode>
            <ram:CategoryCode>S</ram:CategoryCode>
            <ram:RateApplicablePercent>19.00</ram:RateApplicablePercent>
          </ram:ApplicableTradeTax>
          <ram:SpecifiedTradeSettlementLineMonetarySummation>
            <ram:LineTotalAmount>${netto.toFixed(2)}</ram:LineTotalAmount>
          </ram:SpecifiedTradeSettlementLineMonetarySummation>
        </ram:SpecifiedLineTradeSettlement>
      </ram:IncludedSupplyChainTradeLineItem>`;
  }).join('');
  
  const bruttoGesamt = nettoGesamt + mwstGesamt;
  
  // Kunde aufbereiten
  const kunde = dok.kunde || {};
  const kundenName = kunde.name || 'Unbekannt';
  const kundenStrasse = kunde.strasse || '';
  const kundenPLZ = kunde.plz || '';
  const kundenOrt = kunde.ort || '';
  
  // ZUGFeRD XML nach EN 16931 BASIC Profil
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<rsm:CrossIndustryInvoice xmlns:rsm="urn:un:unece:uncefact:data:standard:CrossIndustryInvoice:100"
    xmlns:ram="urn:un:unece:uncefact:data:standard:ReusableAggregateBusinessInformationEntity:100"
    xmlns:qdt="urn:un:unece:uncefact:data:standard:QualifiedDataType:100"
    xmlns:udt="urn:un:unece:uncefact:data:standard:UnqualifiedDataType:100">
  <rsm:ExchangedDocumentContext>
    <ram:GuidelineSpecifiedDocumentContextParameter>
      <ram:ID>urn:cen.eu:en16931:2017#compliant#urn:factur-x.eu:1p0:basic</ram:ID>
    </ram:GuidelineSpecifiedDocumentContextParameter>
  </rsm:ExchangedDocumentContext>
  <rsm:ExchangedDocument>
    <ram:ID>${escapeXML(dok.nummer || 'DRAFT')}</ram:ID>
    <ram:TypeCode>${isAngebot ? '310' : '380'}</ram:TypeCode>
    <ram:IssueDateTime>
      <udt:DateTimeString format="102">${isoDate}</udt:DateTimeString>
    </ram:IssueDateTime>
    <ram:IncludedNote>
      <ram:Content>${escapeXML(dok.betreff || '')}</ram:Content>
    </ram:IncludedNote>
  </rsm:ExchangedDocument>
  <rsm:SupplyChainTradeTransaction>
    <ram:ApplicableHeaderTradeAgreement>
      <ram:SellerTradeParty>
        <ram:Name>${escapeXML(firmenDaten.firmenname || 'Firma')}</ram:Name>
        <ram:PostalTradeAddress>
          <ram:LineOne>${escapeXML(firmenDaten.strasse || '')}</ram:LineOne>
          <ram:PostcodeCode>${escapeXML(firmenDaten.plz || '')}</ram:PostcodeCode>
          <ram:CityName>${escapeXML(firmenDaten.ort || '')}</ram:CityName>
          <ram:CountryID>${escapeXML(firmenDaten.land || 'DE')}</ram:CountryID>
        </ram:PostalTradeAddress>
        <ram:SpecifiedTaxRegistration>
          <ram:ID schemeID="VA">${escapeXML(firmenDaten.ustid || '')}</ram:ID>
        </ram:SpecifiedTaxRegistration>
      </ram:SellerTradeParty>
      <ram:BuyerTradeParty>
        <ram:Name>${escapeXML(kundenName)}</ram:Name>
        <ram:PostalTradeAddress>
          <ram:LineOne>${escapeXML(kundenStrasse)}</ram:LineOne>
          <ram:PostcodeCode>${escapeXML(kundenPLZ)}</ram:PostcodeCode>
          <ram:CityName>${escapeXML(kundenOrt)}</ram:CityName>
          <ram:CountryID>DE</ram:CountryID>
        </ram:PostalTradeAddress>
      </ram:BuyerTradeParty>
    </ram:ApplicableHeaderTradeAgreement>
    <ram:ApplicableHeaderTradeDelivery>
      <ram:ActualDeliverySupplyChainEvent>
        <ram:OccurrenceDateTime>
          <udt:DateTimeString format="102">${isoDate}</udt:DateTimeString>
        </ram:OccurrenceDateTime>
      </ram:ActualDeliverySupplyChainEvent>
    </ram:ApplicableHeaderTradeDelivery>
    <ram:ApplicableHeaderTradeSettlement>
      <ram:InvoiceCurrencyCode>EUR</ram:InvoiceCurrencyCode>
      <ram:SpecifiedTradePaymentTerms>
        <ram:Description>Zahlbar innerhalb von ${firmenDaten.zahlungsziel || 14} Tagen</ram:Description>
      </ram:SpecifiedTradePaymentTerms>
      <ram:ApplicableTradeTax>
        <ram:CalculatedAmount>${mwstGesamt.toFixed(2)}</ram:CalculatedAmount>
        <ram:TypeCode>VAT</ram:TypeCode>
        <ram:BasisAmount>${nettoGesamt.toFixed(2)}</ram:BasisAmount>
        <ram:CategoryCode>S</ram:CategoryCode>
        <ram:RateApplicablePercent>19.00</ram:RateApplicablePercent>
      </ram:ApplicableTradeTax>
      <ram:SpecifiedTradeSettlementHeaderMonetarySummation>
        <ram:LineTotalAmount>${nettoGesamt.toFixed(2)}</ram:LineTotalAmount>
        <ram:TaxBasisTotalAmount>${nettoGesamt.toFixed(2)}</ram:TaxBasisTotalAmount>
        <ram:TaxTotalAmount currencyID="EUR">${mwstGesamt.toFixed(2)}</ram:TaxTotalAmount>
        <ram:GrandTotalAmount>${bruttoGesamt.toFixed(2)}</ram:GrandTotalAmount>
        <ram:DuePayableAmount>${bruttoGesamt.toFixed(2)}</ram:DuePayableAmount>
      </ram:SpecifiedTradeSettlementHeaderMonetarySummation>
    </ram:ApplicableHeaderTradeSettlement>
    ${positionen}
  </rsm:SupplyChainTradeTransaction>
</rsm:CrossIndustryInvoice>`;
  
  return xml;
}

// XML-Escape Helper
function escapeXML(str) {
  if (!str) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRI-HYBRID PDF WORKFLOW - E-Rechnung, RAM-Druck, Sicheres Archiv
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Button A: E-Rechnung (PDF/A-3 mit eingebettetem ZUGFeRD-XML)
async function createEInvoicePDF(dok, firmenDaten, jsPDFInstance) {
  const loading = showLoadingDialog('ğŸ“„ Generiere E-Rechnung...');
  
  try {
    // PDF generieren (verwendet bestehende createPDF Logik)
    loading.updateMessage('ğŸ“ Erstelle PDF...');
    const pdfBlob = jsPDFInstance.output('blob');
    
    // ZUGFeRD-XML im RAM generieren
    loading.updateMessage('ğŸ“‹ Generiere ZUGFeRD-XML...');
    const zugferdXML = generateZUGFeRDXML(dok, firmenDaten);
    
    // PDF/A-3 mit eingebettetem XML erstellen
    loading.updateMessage('ğŸ“¦ Bette XML in PDF ein...');
    
    // FÃ¼r echtes PDF/A-3 mÃ¼sste man eine Library wie pdf-lib verwenden
    // Hier: Workaround - XML als Anhang im PDF-Blob
    const xmlBlob = new Blob([zugferdXML], { type: 'application/xml' });
    
    // Kombiniertes Archiv erstellen (PDF + XML separat)
    const fullName = dok.kunde?.name || 'Unbekannt';
    const cleanName = fullName.replace(/^(Herr|Herrn|Frau|FrÃ¤ulein)\s+/i, '').trim();
    const lastName = cleanName.split(' ').pop().replace(/[^a-zA-Z0-9Ã¤Ã¶Ã¼ÃŸ-]/g, '');
    const baseFileName = `${dok.nummer || 'DRAFT'}-${lastName}`;
    
    loading.close();
    
    // Warnung anzeigen
    const proceed = confirm(
      'âš ï¸ WICHTIGER HINWEIS âš ï¸\n\n' +
      'Die E-Rechnung wird UNVERSCHLÃœSSELT heruntergeladen!\n\n' +
      'â€¢ Geeignet fÃ¼r: Versand an Kunden, Finanzamt\n' +
      'â€¢ Nach Versand: Datei sicher lÃ¶schen!\n' +
      'â€¢ FÃ¼r interne Archivierung: "ğŸ”’ Sicher archivieren" nutzen\n\n' +
      'Fortfahren?'
    );
    
    if (!proceed) return null;
    
    // PDF herunterladen
    const pdfUrl = URL.createObjectURL(pdfBlob);
    const pdfLink = document.createElement('a');
    pdfLink.href = pdfUrl;
    pdfLink.download = `${baseFileName}.pdf`;
    pdfLink.click();
    URL.revokeObjectURL(pdfUrl);
    
    // XML separat herunterladen (fÃ¼r manuelle Einbettung oder Mailanhang)
    const xmlUrl = URL.createObjectURL(xmlBlob);
    const xmlLink = document.createElement('a');
    xmlLink.href = xmlUrl;
    xmlLink.download = `${baseFileName}-factur-x.xml`;
    xmlLink.click();
    URL.revokeObjectURL(xmlUrl);
    
    alert('âœ… E-Rechnung erstellt!\n\n' +
      '2 Dateien wurden heruntergeladen:\n' +
      `â€¢ ${baseFileName}.pdf (Rechnung)\n` +
      `â€¢ ${baseFileName}-factur-x.xml (ZUGFeRD-Daten)\n\n` +
      'âš ï¸ Bitte nach Versand sicher lÃ¶schen!');
    
    return { pdfBlob, xmlBlob };
    
  } catch (err) {
    loading.close();
    console.error('E-Rechnung Fehler:', err);
    alert('Fehler bei E-Rechnung: ' + err.message);
    return null;
  }
}

// Button B: Direkt drucken (RAM-to-Paper, spurenlos)
async function printRAMtoPaper(jsPDFInstance) {
  const loading = showLoadingDialog('ğŸ–¨ï¸ Bereite Druck vor...');
  
  try {
    loading.updateMessage('ğŸ“„ Generiere PDF im RAM...');
    
    // PDF als Blob im RAM
    const pdfBlob = jsPDFInstance.output('blob');
    const blobUrl = URL.createObjectURL(pdfBlob);
    
    loading.updateMessage('ğŸ–¨ï¸ Ã–ffne Druckdialog...');
    
    // Verstecktes iframe fÃ¼r Druck
    const printFrame = document.createElement('iframe');
    printFrame.style.cssText = 'position: fixed; top: -10000px; left: -10000px; width: 1px; height: 1px;';
    document.body.appendChild(printFrame);
    
    printFrame.src = blobUrl;
    
    printFrame.onload = () => {
      loading.close();
      
      try {
        printFrame.contentWindow.focus();
        printFrame.contentWindow.print();
      } catch (e) {
        // Fallback: Neues Fenster Ã¶ffnen
        const printWindow = window.open(blobUrl, '_blank');
        if (printWindow) {
          printWindow.onload = () => {
            printWindow.print();
            // Fenster nach Druck schlieÃŸen
            printWindow.onafterprint = () => printWindow.close();
          };
        }
      }
      
      // Sofort aufrÃ¤umen - Blob aus RAM lÃ¶schen
      setTimeout(() => {
        URL.revokeObjectURL(blobUrl);
        if (printFrame.parentNode) {
          document.body.removeChild(printFrame);
        }
        console.log('âœ“ RAM-Druck: Blob-URL revoked, keine Spuren auf Festplatte');
      }, 1000);
    };
    
    printFrame.onerror = () => {
      loading.close();
      URL.revokeObjectURL(blobUrl);
      if (printFrame.parentNode) {
        document.body.removeChild(printFrame);
      }
      alert('Druckfehler - bitte erneut versuchen');
    };
    
  } catch (err) {
    loading.close();
    console.error('RAM-Druck Fehler:', err);
    alert('Druckfehler: ' + err.message);
  }
}

// Button C: Sicher archivieren (verschlÃ¼sselt mit Padding)
async function createSecureArchive(dok, firmenDaten, jsPDFInstance, vaultPassword) {
  const loading = showLoadingDialog('ğŸ”’ Erstelle sicheres Archiv...');
  
  try {
    loading.updateMessage('ğŸ“„ Generiere PDF im RAM...');
    const pdfArrayBuffer = jsPDFInstance.output('arraybuffer');
    
    loading.updateMessage('ğŸ“‹ Generiere ZUGFeRD-XML...');
    const zugferdXML = generateZUGFeRDXML(dok, firmenDaten);
    const xmlBytes = new TextEncoder().encode(zugferdXML);
    
    loading.updateMessage('ğŸ“¦ Kombiniere Daten...');
    
    // Struktur: [4 Bytes PDF-LÃ¤nge][PDF-Daten][4 Bytes XML-LÃ¤nge][XML-Daten][Padding]
    const pdfLength = pdfArrayBuffer.byteLength;
    const xmlLength = xmlBytes.length;
    const headerSize = 8; // 4 Bytes PDF-LÃ¤nge + 4 Bytes XML-LÃ¤nge
    const dataSize = headerSize + pdfLength + xmlLength;
    
    // Auf 512 KB aufrunden (Privacy Padding)
    const PADDING_BLOCK = 512 * 1024; // 512 KB
    const paddedSize = Math.ceil(dataSize / PADDING_BLOCK) * PADDING_BLOCK;
    const paddingSize = paddedSize - dataSize;
    
    loading.updateMessage(`ğŸ” FÃ¼ge ${Math.round(paddingSize / 1024)} KB Privacy-Padding hinzu...`);
    
    // Buffer erstellen
    const combinedBuffer = new ArrayBuffer(paddedSize);
    const view = new DataView(combinedBuffer);
    const bytes = new Uint8Array(combinedBuffer);
    
    // Header: PDF-LÃ¤nge (4 Bytes, Little-Endian)
    view.setUint32(0, pdfLength, true);
    // Header: XML-LÃ¤nge (4 Bytes, Little-Endian)
    view.setUint32(4, xmlLength, true);
    
    // PDF-Daten
    bytes.set(new Uint8Array(pdfArrayBuffer), headerSize);
    
    // XML-Daten
    bytes.set(xmlBytes, headerSize + pdfLength);
    
    // ZufÃ¤lliges Padding generieren (in Chunks wegen 64KB Limit)
    loading.updateMessage('ğŸ² Generiere kryptografisches Padding...');
    const paddingStart = headerSize + pdfLength + xmlLength;
    const chunkSize = 65536;
    for (let i = 0; i < paddingSize; i += chunkSize) {
      const size = Math.min(chunkSize, paddingSize - i);
      const randomChunk = new Uint8Array(size);
      crypto.getRandomValues(randomChunk);
      bytes.set(randomChunk, paddingStart + i);
    }
    
    loading.updateMessage('ğŸ” VerschlÃ¼ssele mit AES-256-GCM...');
    
    // VerschlÃ¼sseln mit dem Vault-Passwort
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      new TextEncoder().encode(vaultPassword),
      'PBKDF2',
      false,
      ['deriveBits', 'deriveKey']
    );
    
    const key = await crypto.subtle.deriveKey(
      { name: 'PBKDF2', salt, iterations: 310000, hash: 'SHA-256' },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt']
    );
    
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv, tagLength: 128 },
      key,
      combinedBuffer
    );
    
    // Finales Format: [16 Bytes Salt][12 Bytes IV][Encrypted Data]
    const finalBuffer = new ArrayBuffer(16 + 12 + encrypted.byteLength);
    const finalBytes = new Uint8Array(finalBuffer);
    finalBytes.set(salt, 0);
    finalBytes.set(iv, 16);
    finalBytes.set(new Uint8Array(encrypted), 28);
    
    loading.updateMessage('ğŸ’¾ Bereite Download vor...');
    
    // Download als .dat Datei
    const blob = new Blob([finalBuffer], { type: 'application/octet-stream' });
    const filename = `archiv_${Date.now().toString(36)}.dat`;
    
    loading.close();
    
    await saveFile(blob, filename);
    
    alert(`âœ… Sicheres Archiv erstellt!\n\n` +
      `ğŸ“¦ Datei: ${filename}\n` +
      `ğŸ“Š GrÃ¶ÃŸe: ${Math.round(finalBuffer.byteLength / 1024)} KB (mit Padding)\n` +
      `ğŸ” VerschlÃ¼sselt: AES-256-GCM\n\n` +
      `Zum Ã–ffnen: .dat Datei in die Dropzone ziehen`);
    
    return true;
    
  } catch (err) {
    loading.close();
    console.error('Archiv-Fehler:', err);
    alert('Fehler beim Archivieren: ' + err.message);
    return false;
  }
}

// EntschlÃ¼sseln und Anzeigen einer .dat Archivdatei
async function decryptAndViewArchive(file, vaultPassword) {
  const loading = showLoadingDialog('ğŸ”“ EntschlÃ¼ssele Archiv...');
  
  try {
    const arrayBuffer = await file.arrayBuffer();
    const bytes = new Uint8Array(arrayBuffer);
    
    if (bytes.length < 28) {
      throw new Error('UngÃ¼ltige Archivdatei');
    }
    
    loading.updateMessage('ğŸ”‘ Extrahiere SchlÃ¼sselparameter...');
    
    // Salt und IV extrahieren
    const salt = bytes.slice(0, 16);
    const iv = bytes.slice(16, 28);
    const encryptedData = bytes.slice(28);
    
    // SchlÃ¼ssel ableiten
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      new TextEncoder().encode(vaultPassword),
      'PBKDF2',
      false,
      ['deriveBits', 'deriveKey']
    );
    
    const key = await crypto.subtle.deriveKey(
      { name: 'PBKDF2', salt, iterations: 310000, hash: 'SHA-256' },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['decrypt']
    );
    
    loading.updateMessage('ğŸ”“ EntschlÃ¼ssele Daten...');
    
    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv, tagLength: 128 },
      key,
      encryptedData
    );
    
    const decryptedBytes = new Uint8Array(decrypted);
    const view = new DataView(decrypted);
    
    // Header lesen
    const pdfLength = view.getUint32(0, true);
    const xmlLength = view.getUint32(4, true);
    
    loading.updateMessage('ğŸ“„ Extrahiere PDF...');
    
    // PDF extrahieren (ohne Padding)
    const pdfData = decryptedBytes.slice(8, 8 + pdfLength);
    const pdfBlob = new Blob([pdfData], { type: 'application/pdf' });
    
    // XML extrahieren
    const xmlData = decryptedBytes.slice(8 + pdfLength, 8 + pdfLength + xmlLength);
    const xmlString = new TextDecoder().decode(xmlData);
    
    loading.close();
    
    // PDF in neuem Tab anzeigen
    const pdfUrl = URL.createObjectURL(pdfBlob);
    window.open(pdfUrl, '_blank');
    
    // URL nach einer Weile revoken
    setTimeout(() => URL.revokeObjectURL(pdfUrl), 60000);
    
    return { pdfBlob, xmlString };
    
  } catch (err) {
    loading.close();
    console.error('EntschlÃ¼sselungsfehler:', err);
    
    if (err.name === 'OperationError') {
      alert('âŒ Falsches Passwort oder beschÃ¤digte Datei');
    } else {
      alert('Fehler beim EntschlÃ¼sseln: ' + err.message);
    }
    return null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BASE64 KONVERTIERUNG (performant fÃ¼r groÃŸe Daten)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ArrayBuffer zu Base64 - optimiert fÃ¼r 5MB Daten
function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  const chunkSize = 32768; // 32KB Chunks fÃ¼r Performance
  let binary = '';
  
  for (let i = 0; i < bytes.length; i += chunkSize) {
    const chunk = bytes.subarray(i, Math.min(i + chunkSize, bytes.length));
    binary += String.fromCharCode.apply(null, chunk);
  }
  
  return btoa(binary);
}

// Base64 zu ArrayBuffer
function base64ToArrayBuffer(base64) {
  // Entferne mÃ¶gliche Whitespaces/ZeilenumbrÃ¼che
  const cleanBase64 = base64.replace(/[\s\n\r]/g, '');
  const binary = atob(cleanBase64);
  const bytes = new Uint8Array(binary.length);
  
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  
  return bytes.buffer;
}

// PrÃ¼ft ob ein String gÃ¼ltiges Base64 mit unserem Header ist
function isBase64Backup(text) {
  return typeof text === 'string' && text.startsWith('VAULT5MB:');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT/IMPORT FUNKTIONEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Export mit exakt 5 MB Fixed-Size â†’ Base64 Text fÃ¼r Android
async function exportFixedSizeBackup(data, password) {
  // Backup-Objekt erstellen (ohne Datum fÃ¼r Metadaten-Schutz)
  const backup = {
    v: 5,
    f: 'fsb', // fixed-size-backup
    d: data
  };
  
  // Worker fÃ¼r 5MB Fixed-Size VerschlÃ¼sselung
  const encrypted = await workerEncrypt(backup, password, true);
  
  // Verifiziere exakte GrÃ¶ÃŸe (5MB binÃ¤r)
  if (encrypted.byteLength !== VAULT_CONFIG.FIXED_SIZE) {
    throw new Error(`GrÃ¶ÃŸenfehler: ${encrypted.byteLength} statt ${VAULT_CONFIG.FIXED_SIZE} Bytes`);
  }
  
  // In Base64 konvertieren fÃ¼r Android-KompatibilitÃ¤t
  // Header: "VAULT5MB:" fÃ¼r Erkennung beim Import
  const base64 = arrayBufferToBase64(encrypted);
  return 'VAULT5MB:' + base64;
}

// Import von 5MB Fixed-Size Backup (Base64-Text oder Legacy-Binary)
async function importFixedSizeBackup(input, password) {
  let encryptedBuffer;
  
  // PrÃ¼fe ob es Base64-Text mit Header ist
  if (typeof input === 'string') {
    if (!input.startsWith('VAULT5MB:')) {
      throw new Error('UngÃ¼ltiges Backup-Format (Header fehlt)');
    }
    // Header entfernen und Base64 dekodieren
    const base64Data = input.substring(9);
    encryptedBuffer = base64ToArrayBuffer(base64Data);
  } else {
    // Binary ArrayBuffer (Legacy-UnterstÃ¼tzung)
    encryptedBuffer = input;
  }
  
  // GrÃ¶ÃŸe prÃ¼fen (muss exakt 5MB sein)
  if (encryptedBuffer.byteLength !== VAULT_CONFIG.FIXED_SIZE) {
    throw new Error(`UngÃ¼ltige GrÃ¶ÃŸe: ${encryptedBuffer.byteLength} Bytes (erwartet: ${VAULT_CONFIG.FIXED_SIZE})`);
  }
  
  // Worker fÃ¼r EntschlÃ¼sselung nutzen
  const decrypted = await workerDecrypt(encryptedBuffer, password, true);
  
  // Format prÃ¼fen
  if (!decrypted.f || decrypted.f !== 'fsb') {
    throw new Error('UngÃ¼ltiges Backup-Format');
  }
  
  return decrypted.d;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STAMMDATEN EXPORT/IMPORT (ohne Rechnungen/Angebote)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function exportStammdaten(appState, password) {
  const stammdaten = {
    version: 5,
    format: 'stammdaten-encrypted',
    date: new Date().toISOString(),
    kundenListe: appState.kunden || [],
    materialListe: appState.material || [],
    firmenDaten: appState.firmenDaten || {},
    einstellungen: {
      zahlungsziel: appState.firmenDaten?.zahlungsziel,
      angebotsgueltigkeit: appState.firmenDaten?.angebotsgueltigkeit,
      stundensatz: appState.firmenDaten?.stundensatz,
      mwstSatz: 19
    }
    // WICHTIG: rechnungen und angebote werden NICHT exportiert
  };
  
  // VerschlÃ¼sseln OHNE Fixed-Size Padding (temporÃ¤re Transfer-Datei)
  const encrypted = await workerEncrypt(stammdaten, password, false);
  return encrypted;
}

async function importStammdaten(encryptedBuffer, password) {
  // EntschlÃ¼sseln OHNE Fixed-Size Padding
  const stammdaten = await workerDecrypt(encryptedBuffer, password, false);
  
  if (!stammdaten.kundenListe && !stammdaten.materialListe) {
    throw new Error('UngÃ¼ltiges Stammdaten-Format');
  }
  
  return stammdaten;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATEI-EXPORT HILFSFUNKTION - Native Share auf Mobile, Download auf Desktop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleFileExport(blob, filename) {
  let mimeType = blob.type || 'application/octet-stream';
  
  if (filename.endsWith('.txt')) {
    mimeType = 'text/plain';
  } else if (filename.endsWith('.pdf')) {
    mimeType = 'application/pdf';
  }
  
  const file = new File([blob], filename, { type: mimeType });
  
  const hasShare = typeof navigator.share === 'function';
  let canShareFiles = false;
  if (navigator.canShare) {
    try { canShareFiles = navigator.canShare({ files: [file] }); } catch(e) {}
  }

  const doDownload = () => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  if (hasShare && canShareFiles) {
    return new Promise((resolve) => {
      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;';
      overlay.innerHTML = `
        <div style="background:#1e293b;padding:30px;border-radius:15px;text-align:center;max-width:90%;color:white;">
          <h3 style="margin:0 0 10px 0;">ğŸ“„ ${filename}</h3>
          <p style="margin:0 0 20px 0;color:#94a3b8;font-size:14px;">Wie mÃ¶chten Sie die Datei speichern?</p>
          <button id="shareBtn" style="background:#22c55e;color:white;border:none;padding:15px 40px;border-radius:10px;font-size:18px;cursor:pointer;margin:5px;min-width:140px;">ğŸ“¤ Teilen</button>
          <button id="downloadBtn" style="background:#3b82f6;color:white;border:none;padding:15px 40px;border-radius:10px;font-size:18px;cursor:pointer;margin:5px;min-width:140px;">ğŸ’¾ Download</button>
          <br><button id="cancelBtn" style="background:#64748b;color:white;border:none;padding:10px 30px;border-radius:8px;font-size:14px;cursor:pointer;margin-top:15px;">Abbrechen</button>
        </div>
      `;
      document.body.appendChild(overlay);

      overlay.querySelector('#shareBtn').onclick = async () => {
        overlay.remove();
        try {
          await navigator.share({ files: [file], title: filename });
        } catch (err) {
          if (err.name !== 'AbortError') {
            doDownload();
          }
        }
        resolve(true);
      };

      overlay.querySelector('#downloadBtn').onclick = () => {
        overlay.remove();
        doDownload();
        resolve(true);
      };

      overlay.querySelector('#cancelBtn').onclick = () => {
        overlay.remove();
        resolve(false);
      };
    });
  }
  
  doDownload();
  return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PASSWORT-STÃ„RKE PRÃœFUNG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function checkPasswordStrength(password) {
  let score = 0;
  if (password.length >= 8) score += 2;
  if (password.length >= 12) score += 2;
  if (password.length >= 16) score += 1;
  if (/[a-z]/.test(password) && /[A-Z]/.test(password)) score += 2;
  if (/[0-9]/.test(password)) score += 2;
  if (/[^A-Za-z0-9]/.test(password)) score += 2;
  return { score, isStrong: score >= 6 };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PASSWORT-DIALOGE (maskierte Eingabe)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showVaultPasswordDialog(isNewVault = false, allowStammdatenImport = false) {
  return new Promise((resolve) => {
    // Entferne mÃ¶glicherweise existierende alte Overlays
    const existingOverlay = document.querySelector('.vault-overlay');
    if (existingOverlay) existingOverlay.remove();
    
    const dialogId = 'vault-' + Date.now();
    const overlay = document.createElement('div');
    overlay.className = 'vault-overlay';
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95); display: flex; align-items: center;
      justify-content: center; z-index: 99999;
    `;
    overlay.innerHTML = `
      <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        border: 2px solid #0d9488; border-radius: 16px; padding: 32px;
        max-width: 450px; width: 90%; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);">
        <div style="text-align: center; margin-bottom: 20px;">
          <div style="font-size: 50px; margin-bottom: 12px;">ğŸ”</div>
          <h2 style="color: #f8fafc; margin: 0 0 8px 0; font-size: 22px;">
            ${isNewVault ? 'Neuen Tresor erstellen' : 'Tresor entsperren'}
          </h2>
          <p style="color: #94a3b8; margin: 0; font-size: 13px;">
            ${isNewVault 
              ? 'Vergeben Sie ein sicheres Master-Passwort. Dieses Passwort schÃ¼tzt alle Ihre Daten.' 
              : 'Geben Sie Ihr Master-Passwort ein, um auf Ihre Daten zuzugreifen.'}
          </p>
        </div>
        <div style="background: #334155; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
          <label style="display: block; color: #e2e8f0; font-size: 12px; margin-bottom: 6px; font-weight: 600;">
            ${isNewVault ? 'Neues Master-Passwort:' : 'Master-Passwort:'}
          </label>
          <input type="password" id="${dialogId}-pw" placeholder="Mindestens 8 Zeichen..."
            style="width: 100%; padding: 12px 14px; border: 2px solid #475569; border-radius: 8px;
              background: #1e293b; color: #f8fafc; font-size: 16px; box-sizing: border-box; outline: none;" />
          <div id="${dialogId}-strength" style="margin-top: 6px; font-size: 11px; color: #94a3b8;"></div>
          ${isNewVault ? `
            <label style="display: block; color: #e2e8f0; font-size: 12px; margin: 12px 0 6px 0; font-weight: 600;">BestÃ¤tigen:</label>
            <input type="password" id="${dialogId}-confirm" placeholder="Passwort wiederholen..."
              style="width: 100%; padding: 12px 14px; border: 2px solid #475569; border-radius: 8px;
                background: #1e293b; color: #f8fafc; font-size: 16px; box-sizing: border-box; outline: none;" />
            <div id="${dialogId}-match" style="margin-top: 6px; font-size: 11px; color: #94a3b8;"></div>
          ` : ''}
        </div>
        ${allowStammdatenImport ? `
          <div style="background: #1e3a5f; border-radius: 8px; padding: 12px; margin-bottom: 16px; border: 1px solid #3b82f6;">
            <p style="color: #93c5fd; font-size: 11px; margin: 0 0 8px 0;">
              ğŸ“¦ Stammdaten von anderem GerÃ¤t importieren?
            </p>
            <label style="display: inline-block; background: #3b82f6; padding: 8px 16px; border-radius: 6px; cursor: pointer; color: white; font-size: 12px; font-weight: 600;">
              ğŸ“¥ .stammdaten.enc importieren
              <input type="file" id="${dialogId}-import" accept=".enc" style="display: none;" />
            </label>
          </div>
        ` : ''}
        <div style="display: flex; gap: 10px;">
          <button id="${dialogId}-btn" ${isNewVault ? 'disabled' : ''} style="flex: 2; padding: 14px;
            background: linear-gradient(135deg, #0d9488 0%, #0f766e 100%); border: none; border-radius: 8px;
            color: white; font-size: 14px; font-weight: 600; cursor: pointer; opacity: ${isNewVault ? '0.5' : '1'};">
            ${isNewVault ? 'ğŸ”’ Tresor erstellen' : 'ğŸ”“ Entsperren'}
          </button>
        </div>
        <div style="text-align: center; margin-top: 16px;">
          <p style="color: #64748b; font-size: 10px; margin: 0;">
            ğŸ›¡ï¸ AES-256-GCM
          </p>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    const pwInput = document.getElementById(`${dialogId}-pw`);
    const confirmInput = document.getElementById(`${dialogId}-confirm`);
    const strengthDiv = document.getElementById(`${dialogId}-strength`);
    const matchDiv = document.getElementById(`${dialogId}-match`);
    const confirmBtn = document.getElementById(`${dialogId}-btn`);
    const stammdatenInput = document.getElementById(`${dialogId}-import`);
    
    const validate = () => {
      const pw = pwInput.value;
      const confirm = confirmInput?.value || '';
      const strength = checkPasswordStrength(pw);
      
      if (pw.length > 0) {
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#10b981'];
        const labels = ['Sehr schwach', 'Schwach', 'Mittel', 'Stark', 'Sehr stark'];
        const idx = Math.min(Math.floor(strength.score / 2), 4);
        strengthDiv.innerHTML = '<span style="color: ' + colors[idx] + ';">â— ' + labels[idx] + '</span>';
      } else { 
        strengthDiv.innerHTML = ''; 
      }
      
      if (isNewVault && confirm.length > 0) {
        matchDiv.innerHTML = pw === confirm 
          ? '<span style="color: #22c55e;">âœ“ PasswÃ¶rter stimmen Ã¼berein</span>'
          : '<span style="color: #ef4444;">âœ— PasswÃ¶rter stimmen nicht Ã¼berein</span>';
      }
      
      const valid = isNewVault 
        ? (pw.length >= 8 && pw === confirm)
        : (pw.length > 0);
      confirmBtn.disabled = !valid;
      confirmBtn.style.opacity = valid ? '1' : '0.5';
    };
    
    pwInput.addEventListener('input', validate);
    if (confirmInput) confirmInput.addEventListener('input', validate);
    setTimeout(() => pwInput.focus(), 100);
    
    const handleKey = (e) => { 
      if (e.key === 'Enter' && !confirmBtn.disabled) confirmBtn.click(); 
    };
    pwInput.addEventListener('keydown', handleKey);
    if (confirmInput) confirmInput.addEventListener('keydown', handleKey);
    
    // Stammdaten Import Handler
    if (stammdatenInput) {
      stammdatenInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const importPw = prompt('Passwort fÃ¼r die Stammdaten-Datei:');
        if (!importPw) return;
        
        try {
          const buffer = await file.arrayBuffer();
          const stammdaten = await importStammdaten(buffer, importPw);
          overlay.remove();
          resolve({ type: 'stammdaten', data: stammdaten, password: pwInput.value || importPw });
        } catch (err) {
          alert('Import fehlgeschlagen: ' + err.message);
        }
      });
    }
    
    confirmBtn.addEventListener('click', () => { 
      overlay.remove(); 
      resolve({ type: 'password', password: pwInput.value }); 
    });
  });
}

function showExportPasswordDialog() {
  return new Promise((resolve) => {
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.85); display: flex; align-items: center;
      justify-content: center; z-index: 99999;
    `;
    overlay.innerHTML = `
      <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        border: 2px solid #0d9488; border-radius: 16px; padding: 32px;
        max-width: 450px; width: 90%; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);">
        <div style="text-align: center; margin-bottom: 20px;">
          <div style="font-size: 40px; margin-bottom: 12px;">ğŸ”</div>
          <h2 style="color: #f8fafc; margin: 0 0 8px 0; font-size: 20px;">VerschlÃ¼sselter Export</h2>
          <p style="color: #94a3b8; margin: 0; font-size: 13px;">Vergeben Sie ein sicheres Passwort fÃ¼r die Backup-Datei.</p>
        </div>
        <div style="background: #334155; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
          <label style="display: block; color: #e2e8f0; font-size: 12px; margin-bottom: 6px; font-weight: 600;">Passwort:</label>
          <input type="password" id="export-pw" placeholder="Mindestens 8 Zeichen..."
            style="width: 100%; padding: 10px 14px; border: 2px solid #475569; border-radius: 8px;
              background: #1e293b; color: #f8fafc; font-size: 15px; box-sizing: border-box; outline: none;" />
          <div id="pw-strength" style="margin-top: 6px; font-size: 11px; color: #94a3b8;"></div>
          <label style="display: block; color: #e2e8f0; font-size: 12px; margin: 12px 0 6px 0; font-weight: 600;">BestÃ¤tigen:</label>
          <input type="password" id="export-pw-confirm" placeholder="Passwort wiederholen..."
            style="width: 100%; padding: 10px 14px; border: 2px solid #475569; border-radius: 8px;
              background: #1e293b; color: #f8fafc; font-size: 15px; box-sizing: border-box; outline: none;" />
          <div id="pw-match" style="margin-top: 6px; font-size: 11px; color: #94a3b8;"></div>
        </div>
        <div style="display: flex; gap: 10px;">
          <button id="export-cancel" style="flex: 1; padding: 12px; background: #475569; border: none;
            border-radius: 8px; color: #e2e8f0; font-size: 13px; font-weight: 600; cursor: pointer;">Abbrechen</button>
          <button id="export-confirm" disabled style="flex: 2; padding: 12px;
            background: linear-gradient(135deg, #0d9488 0%, #0f766e 100%); border: none; border-radius: 8px;
            color: white; font-size: 13px; font-weight: 600; cursor: pointer; opacity: 0.5;">ğŸ”’ Exportieren</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    const pwInput = document.getElementById('export-pw');
    const confirmInput = document.getElementById('export-pw-confirm');
    const strengthDiv = document.getElementById('pw-strength');
    const matchDiv = document.getElementById('pw-match');
    const confirmBtn = document.getElementById('export-confirm');
    const cancelBtn = document.getElementById('export-cancel');
    
    const validate = () => {
      const pw = pwInput.value;
      const confirm = confirmInput.value;
      const strength = checkPasswordStrength(pw);
      if (pw.length > 0) {
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#10b981'];
        const labels = ['Sehr schwach', 'Schwach', 'Mittel', 'Stark', 'Sehr stark'];
        const idx = Math.min(Math.floor(strength.score / 2), 4);
        strengthDiv.innerHTML = '<span style="color: ' + colors[idx] + ';">â— ' + labels[idx] + '</span>';
      } else { strengthDiv.innerHTML = ''; }
      if (confirm.length > 0) {
        matchDiv.innerHTML = pw === confirm 
          ? '<span style="color: #22c55e;">âœ“ PasswÃ¶rter stimmen Ã¼berein</span>'
          : '<span style="color: #ef4444;">âœ— PasswÃ¶rter stimmen nicht Ã¼berein</span>';
      } else { matchDiv.innerHTML = ''; }
      const valid = pw.length >= 8 && pw === confirm;
      confirmBtn.disabled = !valid;
      confirmBtn.style.opacity = valid ? '1' : '0.5';
    };
    pwInput.addEventListener('input', validate);
    confirmInput.addEventListener('input', validate);
    setTimeout(() => pwInput.focus(), 100);
    
    const handleKey = (e) => { 
      if (e.key === 'Enter' && !confirmBtn.disabled) confirmBtn.click(); 
      else if (e.key === 'Escape') cancelBtn.click(); 
    };
    pwInput.addEventListener('keydown', handleKey);
    confirmInput.addEventListener('keydown', handleKey);
    
    confirmBtn.addEventListener('click', () => { overlay.remove(); resolve(pwInput.value); });
    cancelBtn.addEventListener('click', () => { overlay.remove(); resolve(null); });
  });
}

function showImportPasswordDialog() {
  return new Promise((resolve) => {
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.85); display: flex; align-items: center;
      justify-content: center; z-index: 99999;
    `;
    overlay.innerHTML = `
      <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        border: 2px solid #3b82f6; border-radius: 16px; padding: 32px;
        max-width: 400px; width: 90%; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);">
        <div style="text-align: center; margin-bottom: 20px;">
          <div style="font-size: 40px; margin-bottom: 12px;">ğŸ”“</div>
          <h2 style="color: #f8fafc; margin: 0 0 8px 0; font-size: 20px;">Backup entschlÃ¼sseln</h2>
          <p style="color: #94a3b8; margin: 0; font-size: 13px;">Geben Sie das Passwort fÃ¼r die Backup-Datei ein.</p>
        </div>
        <div style="background: #334155; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
          <input type="password" id="import-pw" placeholder="Passwort eingeben..."
            style="width: 100%; padding: 12px 14px; border: 2px solid #475569; border-radius: 8px;
              background: #1e293b; color: #f8fafc; font-size: 15px; box-sizing: border-box; outline: none;" />
        </div>
        <div style="display: flex; gap: 10px;">
          <button id="import-cancel" style="flex: 1; padding: 12px; background: #475569; border: none;
            border-radius: 8px; color: #e2e8f0; font-size: 13px; font-weight: 600; cursor: pointer;">Abbrechen</button>
          <button id="import-confirm" style="flex: 2; padding: 12px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); border: none; border-radius: 8px;
            color: white; font-size: 13px; font-weight: 600; cursor: pointer;">ğŸ”“ EntschlÃ¼sseln</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    const pwInput = document.getElementById('import-pw');
    const confirmBtn = document.getElementById('import-confirm');
    const cancelBtn = document.getElementById('import-cancel');
    
    setTimeout(() => pwInput.focus(), 100);
    
    pwInput.addEventListener('keydown', (e) => { 
      if (e.key === 'Enter') confirmBtn.click(); 
      else if (e.key === 'Escape') cancelBtn.click(); 
    });
    
    confirmBtn.addEventListener('click', () => { overlay.remove(); resolve(pwInput.value || null); });
    cancelBtn.addEventListener('click', () => { overlay.remove(); resolve(null); });
  });
}
</script>

<script type="text/babel">
const { useState, useEffect, useRef, useCallback, createContext, useContext } = React;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VAULT CONTEXT - Zentraler State mit VerschlÃ¼sselung
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const VaultContext = createContext(null);

const DEFAULT_STATE = {
  kunden: [],
  material: [],
  rechnungen: [],
  angebote: [],
  entwuerfe: [], // Liste aller EntwÃ¼rfe in Bearbeitung
  firmenDaten: {
    id: 1,
    firmenname: "Musterfirma GmbH",
    logo: "",
    logoPosition: "links",
    logoBreite: 40,
    logoHoehe: 15,
    inhaberName: "Max Mustermann",
    strasse: "MusterstraÃŸe 1",
    plz: "12345",
    ort: "Musterstadt",
    land: "Deutschland",
    telefon: "+49 123 456789",
    email: "info@musterfirma.de",
    website: "www.musterfirma.de",
    steuernummer: "123/456/78901",
    bankName: "Musterbank",
    iban: "DE12345678901234567890",
    bic: "MUSTDEFF",
    primaerFarbe: "#006666",
    briefkopfFarbe: "#444444",
    briefkopfAbsender: "inhaber",
    zahlungsziel: 10,
    angebotsgueltigkeit: 30,
    stundensatz: 59,
    angebotHinweis: "Unvorhergesehene Arbeiten werden mit {stundensatz},- â‚¬/Std. abgerechnet."
  },
  meta: {
    version: 5,
    created: new Date().toISOString(),
    lastModified: new Date().toISOString()
  }
};

function VaultProvider({ children }) {
  const [isUnlocked, setIsUnlocked] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [hasExistingVault, setHasExistingVault] = useState(false);
  const [appState, setAppState] = useState(DEFAULT_STATE);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'pending', 'saving', 'error'
  const [lastSaved, setLastSaved] = useState(null);
  
  // Cloud-Sync State
  const HARDCODED_WORKER_URL = 'https://tight-wind-6426.michael-starkulla.workers.dev';
  
  const [cloudConfig, setCloudConfig] = useState(() => {
    // Lade cloudConfig aus localStorage (nicht verschlÃ¼sselt, da nur Lizenzkey)
    // Worker-URL ist fest eingebaut und wird immer Ã¼berschrieben
    try {
      const saved = localStorage.getItem('vault_cloud_config');
      const parsed = saved ? JSON.parse(saved) : { licenseKey: '', enabled: false };
      return { ...parsed, workerUrl: HARDCODED_WORKER_URL };
    } catch {
      return { licenseKey: '', enabled: false, workerUrl: HARDCODED_WORKER_URL };
    }
  });
  const [syncStatus, setSyncStatus] = useState('idle'); // 'idle', 'uploading', 'success', 'error'
  const [lastSyncError, setLastSyncError] = useState(null);
  
  // Speichere cloudConfig in localStorage wenn es sich Ã¤ndert
  useEffect(() => {
    localStorage.setItem('vault_cloud_config', JSON.stringify(cloudConfig));
  }, [cloudConfig]);
  
  const debounceTimerRef = useRef(null);
  const pendingStateRef = useRef(null);
  const hasCheckedCloud = useRef(false);
  
  // PrÃ¼fe beim Start ob ein Vault existiert
  useEffect(() => {
    (async () => {
      try {
        const exists = await SecureVault.hasData();
        setHasExistingVault(exists);
      } catch (err) {
        console.error('Vault-Check fehlgeschlagen:', err);
      }
      setIsLoading(false);
    })();
  }, []);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CLOUD-SYNC FUNKTION - Upload zu Cloudflare R2 via Worker
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  const syncToCloud = useCallback(async (encryptedBlob) => {
    // PrÃ¼fe ob Cloud-Sync aktiviert ist
    if (!cloudConfig.enabled || !cloudConfig.licenseKey || !cloudConfig.workerUrl) {
      console.log('â˜ï¸ Cloud-Sync deaktiviert oder nicht konfiguriert');
      return;
    }
    
    setSyncStatus('uploading');
    setLastSyncError(null);
    
    try {
      console.log('â˜ï¸ Starte Cloud-Sync...');
      
      // Schritt A: Authentifizierung und Presigned URL holen
      const authResponse = await fetch(`${cloudConfig.workerUrl}/auth`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ licenseKey: cloudConfig.licenseKey }),
      });
      
      if (!authResponse.ok) {
        const errorData = await authResponse.json().catch(() => ({}));
        throw new Error(errorData.error || `Auth fehlgeschlagen: ${authResponse.status}`);
      }
      
      const { uploadUrl, downloadUrl, objectKey } = await authResponse.json();
      console.log('â˜ï¸ Presigned URL erhalten fÃ¼r:', objectKey);
      
      // Schritt B: Blob direkt zur Presigned URL hochladen
      const uploadResponse = await fetch(uploadUrl, {
        method: 'PUT',
        body: encryptedBlob,
        headers: {
          'Content-Type': 'application/octet-stream',
        },
      });
      
      if (!uploadResponse.ok) {
        throw new Error(`Upload fehlgeschlagen: ${uploadResponse.status}`);
      }
      
      console.log('â˜ï¸ Cloud-Sync erfolgreich!');
      setSyncStatus('success');
      
      // Status nach 3 Sekunden auf idle zurÃ¼cksetzen
      setTimeout(() => setSyncStatus('idle'), 3000);
      
    } catch (err) {
      console.error('â˜ï¸ Cloud-Sync Fehler:', err);
      setSyncStatus('error');
      setLastSyncError(err.message);
      
      // Status nach 5 Sekunden auf idle zurÃ¼cksetzen
      setTimeout(() => setSyncStatus('idle'), 5000);
    }
  }, [cloudConfig]);
  
  // Debounced Save Funktion
  const saveToVault = useCallback(async (stateToSave) => {
    if (!SecureVault.encryptionKey) return;
    
    setSaveStatus('saving');
    try {
      const stateWithMeta = {
        ...stateToSave,
        meta: {
          ...stateToSave.meta,
          lastModified: new Date().toISOString()
        }
      };
      
      // VerschlÃ¼ssele die Daten (wird auch fÃ¼r Cloud-Sync benÃ¶tigt)
      const encrypted = await workerEncrypt(stateWithMeta, SecureVault.encryptionKey, true);
      
      // Lokales Speichern in IndexedDB (blockierend)
      const db = await SecureVault.openDB();
      await new Promise((resolve, reject) => {
        const tx = db.transaction(VAULT_CONFIG.STORE_NAME, 'readwrite');
        const store = tx.objectStore(VAULT_CONFIG.STORE_NAME);
        const req = store.put(encrypted, VAULT_CONFIG.KEY_NAME);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
      
      setSaveStatus('saved');
      setLastSaved(new Date());
      console.log('âœ“ Vault gespeichert (5MB Fixed-Size)');
      
      // Fire-and-Forget: Cloud-Sync NACH erfolgreichem lokalen Speichern
      // Kein await - UI blockiert nicht
      if (cloudConfig.enabled) {
        const blob = new Blob([encrypted], { type: 'application/octet-stream' });
        syncToCloud(blob);
      }
      
    } catch (err) {
      console.error('Speichern fehlgeschlagen:', err);
      setSaveStatus('error');
    }
  }, [cloudConfig.enabled, syncToCloud]);
  
  // Debouncing: Speichert erst nach 2 Sekunden InaktivitÃ¤t
  const queueSave = useCallback((newState) => {
    pendingStateRef.current = newState;
    setSaveStatus('pending');
    
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    
    debounceTimerRef.current = setTimeout(() => {
      if (pendingStateRef.current) {
        saveToVault(pendingStateRef.current);
        pendingStateRef.current = null;
      }
    }, VAULT_CONFIG.DEBOUNCE_MS);
  }, [saveToVault]);
  
  // State-Update mit automatischem Debounced Save
  const updateState = useCallback((updater) => {
    setAppState(prev => {
      const newState = typeof updater === 'function' ? updater(prev) : { ...prev, ...updater };
      queueSave(newState);
      return newState;
    });
  }, [queueSave]);
  
  // Sofortiges Speichern (z.B. beim Klick auf "Speichern")
  const forceSave = useCallback(async () => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
      debounceTimerRef.current = null;
    }
    const stateToSave = pendingStateRef.current || appState;
    pendingStateRef.current = null;
    await saveToVault(stateToSave);
  }, [appState, saveToVault]);
  
  // Vault entsperren
  const unlockVault = useCallback(async (password) => {
    try {
      setIsLoading(true);
      const data = await SecureVault.load(password);
      if (data) {
        setAppState(data);
      }
      setIsUnlocked(true);
      setIsLoading(false);
      return true;
    } catch (err) {
      setIsLoading(false);
      throw err;
    }
  }, []);
  
  // Neuen Vault erstellen
  const createVault = useCallback(async (password, initialData = DEFAULT_STATE) => {
    try {
      setIsLoading(true);
      await SecureVault.initialize(password, initialData);
      setAppState(initialData);
      setIsUnlocked(true);
      setHasExistingVault(true);
      setIsLoading(false);
      return true;
    } catch (err) {
      setIsLoading(false);
      throw err;
    }
  }, []);
  
  // Vault mit Stammdaten initialisieren
  const initializeWithStammdaten = useCallback(async (password, stammdaten) => {
    const newState = {
      ...DEFAULT_STATE,
      kunden: stammdaten.kundenListe || [],
      material: stammdaten.materialListe || [],
      firmenDaten: { ...DEFAULT_STATE.firmenDaten, ...stammdaten.firmenDaten },
      rechnungen: [], // WICHTIG: Keine alten Rechnungen
      angebote: [], // WICHTIG: Keine alten Angebote
      meta: {
        version: 5,
        created: new Date().toISOString(),
        lastModified: new Date().toISOString(),
        importedFrom: stammdaten.date
      }
    };
    return createVault(password, newState);
  }, [createVault]);
  
  // Sauberes Sperren des Vaults (Logout)
  const lockVault = useCallback(async () => {
    // Erst ausstehende Ã„nderungen speichern
    if (pendingStateRef.current || saveStatus === 'pending') {
      await forceSave();
    }
    // Dann sauber sperren
    SecureVault.emergencyWipe();
    setIsUnlocked(false);
    setAppState(DEFAULT_STATE);
    setSaveStatus('saved');
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    pendingStateRef.current = null;
  }, [forceSave, saveStatus]);
  
  // Stammdaten exportieren
  const exportStammdatenFile = useCallback(async () => {
    const password = await showExportPasswordDialog();
    if (!password) return;
    
    try {
      const encrypted = await exportStammdaten(appState, password);
      const blob = new Blob([encrypted], { type: 'application/octet-stream' });
      const filename = `stammdaten-${new Date().toISOString().slice(0,10)}.stammdaten.enc`;
      await handleFileExport(blob, filename);
    } catch (err) {
      alert('Export fehlgeschlagen: ' + err.message);
    }
  }, [appState]);
  
  // VollstÃ¤ndiges Backup exportieren (5MB Fixed-Size â†’ Base64 Text fÃ¼r Android)
  const exportFullBackup = useCallback(async () => {
    const password = await showExportPasswordDialog();
    if (!password) return;
    
    const loading = showLoadingDialog('ğŸ” VerschlÃ¼ssele Backup...');
    
    try {
      loading.updateMessage('âš™ï¸ Generiere 5MB Privacy-Padding...');
      
      // Kryptografisch anonymisierte 5MB Fixed-Size VerschlÃ¼sselung â†’ Base64
      const base64Text = await exportFixedSizeBackup(appState, password);
      
      loading.updateMessage('ğŸ“¦ Konvertiere fÃ¼r Android...');
      
      // Base64 Text (ca. 7MB durch Base64-Overhead)
      console.log(`âœ“ Export-GrÃ¶ÃŸe: ${base64Text.length} Zeichen (Base64)`);
      console.log(`âœ“ BinÃ¤r-Ã„quivalent: ${VAULT_CONFIG.FIXED_SIZE} Bytes (5 MB)`);
      
      // Als Text-Datei fÃ¼r Android Share-KompatibilitÃ¤t
      const blob = new Blob([base64Text], { type: 'text/plain;charset=utf-8' });
      
      // Neutraler Dateiname (.txt fÃ¼r Android)
      const filename = getRandomNeutralFilename();
      
      loading.close();
      await handleFileExport(blob, filename);
      
    } catch (err) {
      loading.close();
      console.error('Export-Fehler:', err);
      alert('Export fehlgeschlagen: ' + err.message);
    }
  }, [appState]);
  
  // Backup importieren (unterstÃ¼tzt Base64-Text, Fixed-Size und Legacy-Format)
  const importBackupFile = useCallback(async (file) => {
    const isEncrypted = file.name.endsWith('.txt') || file.name.endsWith('.enc') || 
                        file.name.endsWith('.dat') || file.name.endsWith('.bin') ||
                        file.name.endsWith('.tmp') || file.name.endsWith('.sys');
    
    if (isEncrypted) {
      const password = await showImportPasswordDialog();
      if (!password) return;
      
      const loading = showLoadingDialog('ğŸ”“ EntschlÃ¼ssele Backup...');
      
      try {
        let data;
        
        // Erst als Text lesen um Base64-Format zu prÃ¼fen
        const textContent = await file.text();
        
        if (isBase64Backup(textContent)) {
          // Neues Base64-Format (5MB Fixed-Size als Text)
          loading.updateMessage('ğŸ“¦ Dekodiere Base64-Backup...');
          console.log('âœ“ Base64-Backup erkannt, LÃ¤nge:', textContent.length);
          data = await importFixedSizeBackup(textContent, password);
          
        } else {
          // Binary-Format (Legacy oder altes Fixed-Size)
          loading.updateMessage('ğŸ“¦ Verarbeite Binary-Backup...');
          const buffer = await file.arrayBuffer();
          
          if (buffer.byteLength === VAULT_CONFIG.FIXED_SIZE) {
            // Legacy 5MB Fixed-Size Binary
            data = await importFixedSizeBackup(buffer, password);
          } else {
            // Altes Legacy-Format
            data = await decryptData(buffer, password);
          }
        }
        
        loading.close();
        
        if (!data.kunden && !data.material) throw new Error('UngÃ¼ltiges Format');
        
        if (!confirm('Aktuelle Daten Ã¼berschreiben? Alle lokalen Ã„nderungen gehen verloren!')) return;
        
        const newState = {
          ...DEFAULT_STATE,
          kunden: data.kunden || [],
          material: data.material || [],
          rechnungen: data.rechnungen || [],
          angebote: data.angebote || [],
          firmenDaten: { ...DEFAULT_STATE.firmenDaten, ...(data.firmenDaten || data.einstellungen?.[0] || {}) },
          meta: {
            version: 5,
            created: data.meta?.created || new Date().toISOString(),
            lastModified: new Date().toISOString(),
            importedFrom: 'backup-import'
          }
        };
        
        updateState(newState);
        await forceSave();
        alert('Import erfolgreich!');
      } catch (err) {
        loading.close();
        alert('Import fehlgeschlagen: ' + err.message);
      }
    }
  }, [updateState, forceSave]);
  
  // Cloud-Config aktualisieren
  const updateCloudConfig = useCallback((newConfig) => {
    setCloudConfig(prev => ({ ...prev, ...newConfig }));
  }, []);
  
  // Manueller Cloud-Sync auslÃ¶sen
  const triggerCloudSync = useCallback(async () => {
    if (!SecureVault.encryptionKey) {
      console.warn('Vault nicht entsperrt');
      return;
    }
    
    try {
      const encrypted = await workerEncrypt(appState, SecureVault.encryptionKey, true);
      const blob = new Blob([encrypted], { type: 'application/octet-stream' });
      await syncToCloud(blob);
    } catch (err) {
      console.error('Manueller Sync fehlgeschlagen:', err);
    }
  }, [appState, syncToCloud]);
  
  // Cloud-Restore: Backup aus Cloud wiederherstellen
  const restoreFromCloud = useCallback(async () => {
    if (!cloudConfig.enabled || !cloudConfig.licenseKey || !cloudConfig.workerUrl) {
      alert('Cloud-Sync ist nicht konfiguriert.');
      return;
    }
    
    if (!SecureVault.encryptionKey) {
      alert('Vault nicht entsperrt.');
      return;
    }
    
    // Benutzer wÃ¤hlt Modus: Merge oder Ãœberschreiben
    const userChoice = prompt(
      'â˜ï¸ Cloud-Backup laden\n\n' +
      'WÃ¤hlen Sie den Modus:\n\n' +
      '1 = ZUSAMMENFÃœHREN (empfohlen)\n' +
      '    â†’ Lokale Daten bleiben erhalten\n' +
      '    â†’ Neue Cloud-Daten werden hinzugefÃ¼gt\n\n' +
      '2 = VOLLSTÃ„NDIG ERSETZEN\n' +
      '    â†’ ALLE lokalen Daten werden gelÃ¶scht\n' +
      '    â†’ Nur Cloud-Daten bleiben\n\n' +
      'Geben Sie 1 oder 2 ein:'
    );
    
    if (!userChoice || (userChoice !== '1' && userChoice !== '2')) {
      return;
    }
    
    const useFullReplace = userChoice === '2';
    
    if (useFullReplace && !confirm('âš ï¸ WARNUNG!\n\nALLE lokalen Daten werden UNWIDERRUFLICH gelÃ¶scht!\n\nSind Sie absolut sicher?')) {
      return;
    }
    
    setSyncStatus('downloading');
    setLastSyncError(null);
    const loading = showLoadingDialog('â˜ï¸ Lade Backup aus Cloud...');
    
    try {
      // 1. URL holen
      const authResponse = await fetch(`${cloudConfig.workerUrl}/auth`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ licenseKey: cloudConfig.licenseKey }),
      });
      
      if (!authResponse.ok) throw new Error('Authentifizierung fehlgeschlagen');
      const { downloadUrl } = await authResponse.json();

      // 2. Datei herunterladen
      loading.updateMessage('ğŸ“¥ Lade Daten...');
      const fileResponse = await fetch(downloadUrl);
      if (!fileResponse.ok) throw new Error('Download fehlgeschlagen');
      
      // Als ArrayBuffer lesen (wichtig fÃ¼r BinÃ¤rdaten!)
      const encryptedBuffer = await fileResponse.arrayBuffer();

      // 3. DIREKT entschlÃ¼sseln (Umgeht importFixedSizeBackup!)
      loading.updateMessage('ğŸ”“ EntschlÃ¼ssele...');
      let cloudData = await workerDecrypt(encryptedBuffer, SecureVault.encryptionKey, true);

      // 4. PrÃ¼fen ob es vielleicht doch ein Export-Container ist (Wrapper entfernen)
      if (cloudData && cloudData.f === 'fsb' && cloudData.d) {
        cloudData = cloudData.d;
      }

      // 5. Inhalt prÃ¼fen
      if (!cloudData || (!cloudData.kunden && !cloudData.material)) {
        throw new Error('EntschlÃ¼sselte Daten sind leer oder ungÃ¼ltig');
      }

      // 6. State wiederherstellen
      loading.updateMessage('ğŸ’¾ Speichere...');
      
      let newState;
      let resultMessage;
      
      if (useFullReplace) {
        // MODUS 2: VollstÃ¤ndig ersetzen
        newState = {
          ...DEFAULT_STATE,
          kunden: cloudData.kunden || [],
          material: cloudData.material || [],
          rechnungen: cloudData.rechnungen || [],
          angebote: cloudData.angebote || [],
          entwuerfe: cloudData.entwuerfe || [],
          firmenDaten: { ...DEFAULT_STATE.firmenDaten, ...(cloudData.firmenDaten || {}) },
          meta: { ...cloudData.meta, restoredFrom: 'cloud-full-restore' }
        };
        resultMessage = 'âœ… Cloud-Backup vollstÃ¤ndig wiederhergestellt!\n\nAlle lokalen Daten wurden ersetzt.';
      } else {
        // MODUS 1: Smart Merge
        const { mergedData, stats } = mergeAllData(appState, cloudData);
        
        newState = {
          ...DEFAULT_STATE,
          kunden: mergedData.kunden,
          material: mergedData.material,
          rechnungen: mergedData.rechnungen,
          angebote: mergedData.angebote,
          entwuerfe: mergedData.entwuerfe,
          firmenDaten: { ...DEFAULT_STATE.firmenDaten, ...(appState.firmenDaten || {}), ...(cloudData.firmenDaten || {}) },
          meta: { 
            ...appState.meta,
            lastModified: new Date().toISOString(),
            lastMerge: new Date().toISOString(),
            mergeSource: 'cloud-manual-restore'
          }
        };
        resultMessage = `âœ… Cloud-Sync abgeschlossen!\n\n${stats.totalAdded} EintrÃ¤ge hinzugefÃ¼gt\n${stats.totalUpdated} EintrÃ¤ge aktualisiert\n\nLokale Daten wurden beibehalten.`;
      }

      updateState(newState);
      await forceSave();
      
      loading.close();
      setSyncStatus('success');
      setTimeout(() => setSyncStatus('idle'), 3000);
      alert(resultMessage);

    } catch (err) {
      loading.close();
      console.error(err);
      setSyncStatus('error');
      
      if (err.name === 'OperationError' || err.message.includes('Check failed')) {
         alert('âŒ EntschlÃ¼sselung fehlgeschlagen.\nFalsches Passwort oder Datei beschÃ¤digt.');
      } else {
         alert('Fehler: ' + err.message);
      }
    }
  }, [cloudConfig, appState, updateState, forceSave, mergeAllData]);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SMART MERGE - Intelligentes ZusammenfÃ¼hren von Daten ohne Datenverlust
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /**
   * FÃ¼hrt zwei Listen anhand ihrer ID zusammen
   * - Elemente die nur lokal existieren â†’ behalten
   * - Elemente die nur in Cloud existieren â†’ hinzufÃ¼gen
   * - Elemente die in beiden existieren â†’ neueres behalten (lastModified)
   * @returns {merged: Array, stats: {added: number, updated: number, unchanged: number}}
   */
  const mergeLists = useCallback((localList = [], cloudList = [], idField = 'id') => {
    const localMap = new Map();
    const stats = { added: 0, updated: 0, unchanged: 0 };
    
    // Alle lokalen EintrÃ¤ge in Map
    localList.forEach(item => {
      if (item && item[idField]) {
        localMap.set(item[idField], item);
      }
    });
    
    // Cloud-EintrÃ¤ge durchgehen
    cloudList.forEach(cloudItem => {
      if (!cloudItem || !cloudItem[idField]) return;
      
      const localItem = localMap.get(cloudItem[idField]);
      
      if (!localItem) {
        // Element existiert nur in Cloud â†’ hinzufÃ¼gen
        localMap.set(cloudItem[idField], cloudItem);
        stats.added++;
      } else {
        // Element existiert in beiden â†’ vergleiche Zeitstempel
        const cloudTime = cloudItem.lastModified || cloudItem.datum || 0;
        const localTime = localItem.lastModified || localItem.datum || 0;
        
        const cloudDate = new Date(cloudTime).getTime() || 0;
        const localDate = new Date(localTime).getTime() || 0;
        
        if (cloudDate > localDate) {
          // Cloud ist neuer â†’ Ã¼bernehmen
          localMap.set(cloudItem[idField], cloudItem);
          stats.updated++;
        } else {
          stats.unchanged++;
        }
      }
    });
    
    return {
      merged: Array.from(localMap.values()),
      stats
    };
  }, []);
  
  /**
   * FÃ¼hrt alle Datenlisten zusammen und liefert Statistiken
   */
  const mergeAllData = useCallback((localData, cloudData) => {
    const results = {
      kunden: mergeLists(localData.kunden, cloudData.kunden, 'id'),
      material: mergeLists(localData.material, cloudData.material, 'id'),
      rechnungen: mergeLists(localData.rechnungen, cloudData.rechnungen, 'id'),
      angebote: mergeLists(localData.angebote, cloudData.angebote, 'id'),
      entwuerfe: mergeLists(localData.entwuerfe, cloudData.entwuerfe, 'entwurfId'),
    };
    
    // Gesamtstatistik
    const totalAdded = Object.values(results).reduce((sum, r) => sum + r.stats.added, 0);
    const totalUpdated = Object.values(results).reduce((sum, r) => sum + r.stats.updated, 0);
    
    return {
      mergedData: {
        kunden: results.kunden.merged,
        material: results.material.merged,
        rechnungen: results.rechnungen.merged,
        angebote: results.angebote.merged,
        entwuerfe: results.entwuerfe.merged,
      },
      stats: {
        kunden: results.kunden.stats,
        material: results.material.stats,
        rechnungen: results.rechnungen.stats,
        angebote: results.angebote.stats,
        entwuerfe: results.entwuerfe.stats,
        totalAdded,
        totalUpdated
      }
    };
  }, [mergeLists]);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CLOUD-UPDATE CHECK - PrÃ¼ft beim Start ob neuere Daten in der Cloud sind
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  const checkCloudUpdate = useCallback(async () => {
    // Nur prÃ¼fen wenn Cloud konfiguriert ist
    if (!cloudConfig.enabled || !cloudConfig.licenseKey || !cloudConfig.workerUrl) {
      return;
    }
    
    if (!SecureVault.encryptionKey) {
      return;
    }
    
    try {
      console.log('â˜ï¸ PrÃ¼fe auf Cloud-Updates...');
      
      // 1. Download-URL holen
      const authResponse = await fetch(`${cloudConfig.workerUrl}/auth`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ licenseKey: cloudConfig.licenseKey }),
      });
      
      if (!authResponse.ok) {
        console.log('â˜ï¸ Auth fehlgeschlagen, Ã¼berspringe Cloud-Check');
        return;
      }
      
      const { downloadUrl } = await authResponse.json();
      
      // 2. Cloud-Daten herunterladen
      const fileResponse = await fetch(downloadUrl);
      
      if (!fileResponse.ok) {
        if (fileResponse.status === 404) {
          console.log('â˜ï¸ Kein Cloud-Backup vorhanden');
          return;
        }
        console.log('â˜ï¸ Download fehlgeschlagen:', fileResponse.status);
        return;
      }
      
      const encryptedBuffer = await fileResponse.arrayBuffer();
      
      // 3. EntschlÃ¼sseln
      let cloudData = await workerDecrypt(encryptedBuffer, SecureVault.encryptionKey, true);
      
      // Falls Export-Container, entpacken
      if (cloudData && cloudData.f === 'fsb' && cloudData.d) {
        cloudData = cloudData.d;
      }
      
      // 4. Validieren
      if (!cloudData || (!cloudData.kunden && !cloudData.material)) {
        console.log('â˜ï¸ Cloud-Daten ungÃ¼ltig oder leer');
        return;
      }
      
      // 5. Zeitstempel fÃ¼r Anzeige holen
      const cloudModified = cloudData.meta?.lastModified ? new Date(cloudData.meta.lastModified) : null;
      const localModified = appState.meta?.lastModified ? new Date(appState.meta.lastModified) : null;
      
      // 6. Benutzer fragen
      const cloudDateStr = cloudModified ? cloudModified.toLocaleString('de-DE', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      }) : 'unbekannt';
      
      const localDateStr = localModified ? localModified.toLocaleString('de-DE', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      }) : 'unbekannt';
      
      // 7. SMART MERGE - Daten zusammenfÃ¼hren statt Ã¼berschreiben
      const { mergedData, stats } = mergeAllData(appState, cloudData);
      
      // PrÃ¼fen ob Ã¼berhaupt etwas zu mergen ist
      if (stats.totalAdded === 0 && stats.totalUpdated === 0) {
        console.log('â˜ï¸ Keine neuen Daten in der Cloud');
        return;
      }
      
      // Merge-Zusammenfassung erstellen
      const summaryParts = [];
      if (stats.kunden.added > 0) summaryParts.push(`${stats.kunden.added} neue Kunden`);
      if (stats.kunden.updated > 0) summaryParts.push(`${stats.kunden.updated} aktualisierte Kunden`);
      if (stats.material.added > 0) summaryParts.push(`${stats.material.added} neue Materialien`);
      if (stats.material.updated > 0) summaryParts.push(`${stats.material.updated} aktualisierte Materialien`);
      if (stats.rechnungen.added > 0) summaryParts.push(`${stats.rechnungen.added} neue Rechnungen`);
      if (stats.rechnungen.updated > 0) summaryParts.push(`${stats.rechnungen.updated} aktualisierte Rechnungen`);
      if (stats.angebote.added > 0) summaryParts.push(`${stats.angebote.added} neue Angebote`);
      if (stats.angebote.updated > 0) summaryParts.push(`${stats.angebote.updated} aktualisierte Angebote`);
      if (stats.entwuerfe.added > 0) summaryParts.push(`${stats.entwuerfe.added} neue EntwÃ¼rfe`);
      if (stats.entwuerfe.updated > 0) summaryParts.push(`${stats.entwuerfe.updated} aktualisierte EntwÃ¼rfe`);
      
      const summaryText = summaryParts.join('\nâ€¢ ');
      
      const shouldMerge = confirm(
        `â˜ï¸ Cloud-Backup gefunden!\n\n` +
        `Cloud: ${cloudDateStr}\n` +
        `Lokal: ${localDateStr}\n\n` +
        `Folgende Daten werden zusammengefÃ¼hrt:\nâ€¢ ${summaryText}\n\n` +
        `MÃ¶chten Sie die Daten zusammenfÃ¼hren?\n` +
        `(Lokale Daten bleiben erhalten, neue werden hinzugefÃ¼gt)`
      );
      
      if (!shouldMerge) {
        console.log('â˜ï¸ Benutzer hat Cloud-Merge abgelehnt');
        return;
      }
      
      // 7. Gemergte Daten Ã¼bernehmen
      const newState = {
        ...DEFAULT_STATE,
        kunden: mergedData.kunden,
        material: mergedData.material,
        rechnungen: mergedData.rechnungen,
        angebote: mergedData.angebote,
        entwuerfe: mergedData.entwuerfe,
        firmenDaten: { ...DEFAULT_STATE.firmenDaten, ...(cloudData.firmenDaten || {}), ...(appState.firmenDaten || {}) },
        meta: { 
          ...appState.meta,
          lastModified: new Date().toISOString(),
          lastMerge: new Date().toISOString(),
          mergeSource: 'cloud-auto-check'
        }
      };
      
      updateState(newState);
      await forceSave();
      
      console.log('â˜ï¸ Cloud-Daten erfolgreich gemerged:', stats);
      alert(`âœ… Cloud-Sync abgeschlossen!\n\n${stats.totalAdded} EintrÃ¤ge hinzugefÃ¼gt\n${stats.totalUpdated} EintrÃ¤ge aktualisiert`);
      
    } catch (err) {
      // Silent fail - nur loggen, nicht den User stÃ¶ren
      console.error('â˜ï¸ Cloud-Check Fehler (silent):', err.message);
    }
  }, [cloudConfig, appState, updateState, forceSave, mergeAllData]);
  
  // Effect: Cloud-Check nach erfolgreichem Login
  useEffect(() => {
    if (isUnlocked && cloudConfig.enabled) {
      // Verhindere doppelten Aufruf
      if (hasCheckedCloud.current) return;
      
      hasCheckedCloud.current = true;
      checkCloudUpdate();
    } else if (!isUnlocked) {
      // Reset beim Ausloggen, damit beim nÃ¤chsten Login wieder geprÃ¼ft wird
      hasCheckedCloud.current = false;
    }
  }, [isUnlocked, cloudConfig.enabled, checkCloudUpdate]);
  
  const value = {
    isUnlocked,
    isLoading,
    hasExistingVault,
    appState,
    saveStatus,
    lastSaved,
    updateState,
    forceSave,
    unlockVault,
    createVault,
    initializeWithStammdaten,
    lockVault,
    exportStammdatenFile,
    exportFullBackup,
    importBackupFile,
    // Cloud-Sync
    cloudConfig,
    updateCloudConfig,
    syncStatus,
    lastSyncError,
    triggerCloudSync,
    restoreFromCloud
  };
  
  return (
    <VaultContext.Provider value={value}>
      {children}
    </VaultContext.Provider>
  );
}

function useVault() {
  const context = useContext(VaultContext);
  if (!context) throw new Error('useVault muss innerhalb VaultProvider verwendet werden');
  return context;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOGIN SCREEN - Passwort-Abfrage beim Start
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function LoginScreen() {
  const { hasExistingVault, unlockVault, createVault, initializeWithStammdaten } = useVault();
  const [error, setError] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const hasStartedRef = useRef(false);
  
  useEffect(() => {
    // Verhindere mehrfache Aufrufe
    if (hasStartedRef.current) return;
    hasStartedRef.current = true;
    
    const handleLogin = async () => {
      setIsProcessing(true);
      setError('');
      
      try {
        const result = await showVaultPasswordDialog(!hasExistingVault, !hasExistingVault);
        
        if (!result || !result.password) {
          setError('Kein Passwort eingegeben');
          setIsProcessing(false);
          hasStartedRef.current = false;
          return;
        }
        
        if (result.type === 'stammdaten') {
          await initializeWithStammdaten(result.password, result.data);
        } else if (result.type === 'password') {
          if (hasExistingVault) {
            await unlockVault(result.password);
          } else {
            await createVault(result.password);
          }
        }
        // Erfolg - der VaultApp wird automatisch MainApp rendern
      } catch (err) {
        console.error('Login-Fehler:', err);
        setError(err.message || 'Unbekannter Fehler');
        setIsProcessing(false);
        hasStartedRef.current = false;
        // Bei Fehler: Button zum erneuten Versuch anzeigen
      }
    };
    
    handleLogin();
  }, []); // Keine Dependencies - nur einmal ausfÃ¼hren
  
  const retryLogin = () => {
    hasStartedRef.current = false;
    setError('');
    setIsProcessing(true);
    
    const handleRetry = async () => {
      try {
        const result = await showVaultPasswordDialog(!hasExistingVault, !hasExistingVault);
        
        if (!result || !result.password) {
          setError('Kein Passwort eingegeben');
          setIsProcessing(false);
          return;
        }
        
        if (result.type === 'stammdaten') {
          await initializeWithStammdaten(result.password, result.data);
        } else if (result.type === 'password') {
          if (hasExistingVault) {
            await unlockVault(result.password);
          } else {
            await createVault(result.password);
          }
        }
      } catch (err) {
        console.error('Login-Fehler:', err);
        setError(err.message || 'Unbekannter Fehler');
        setIsProcessing(false);
      }
    };
    
    handleRetry();
  };
  
  return (
    <div style={{
      position: 'fixed',
      top: 0, left: 0, right: 0, bottom: 0,
      background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      flexDirection: 'column',
      color: 'white'
    }}>
      <div style={{ fontSize: '60px', marginBottom: '20px' }}>ğŸ”</div>
      <h1 style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '10px' }}>
        Secure Vault
      </h1>
      <p style={{ color: '#94a3b8', fontSize: '14px' }}>
        {isProcessing ? 'Verarbeite...' : 'Warte auf Eingabe...'}
      </p>
      {error && (
        <div style={{ marginTop: '20px', textAlign: 'center' }}>
          <p style={{ color: '#ef4444', fontSize: '14px', marginBottom: '15px' }}>
            âš ï¸ {error}
          </p>
          <button 
            onClick={retryLogin}
            style={{
              background: 'linear-gradient(135deg, #0d9488 0%, #0f766e 100%)',
              color: 'white',
              border: 'none',
              padding: '12px 24px',
              borderRadius: '8px',
              fontSize: '14px',
              fontWeight: '600',
              cursor: 'pointer'
            }}
          >
            ğŸ”„ Erneut versuchen
          </button>
        </div>
      )}
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HAUPTANWENDUNG (mit Vault-Integration)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function MainApp() {
  const { 
    appState, 
    updateState, 
    forceSave, 
    saveStatus, 
    lastSaved,
    lockVault,
    exportStammdatenFile,
    exportFullBackup,
    importBackupFile,
    // Cloud-Sync
    cloudConfig,
    updateCloudConfig,
    syncStatus,
    lastSyncError,
    triggerCloudSync,
    restoreFromCloud
  } = useVault();
  
  // Lokale State-Werte aus appState extrahieren
  const db = { kunden: appState.kunden, material: appState.material };
  const rechnungen = [...appState.rechnungen, ...appState.angebote];
  const firmenDaten = appState.firmenDaten;
  
  // Speicher-Ãœberwachung: Berechne wie viel Platz belegt ist
  const speicherInfo = React.useMemo(() => {
    // JSON-GrÃ¶ÃŸe der Nutzdaten berechnen
    const jsonString = JSON.stringify(appState);
    const bytesUsed = new TextEncoder().encode(jsonString).length;
    
    // VerfÃ¼gbarer Platz im 5MB Container (abzÃ¼glich Overhead fÃ¼r Salt, IV, Tag, LÃ¤ngenfeld)
    const overhead = 16 + 12 + 16 + 4; // salt + iv + tag + length field
    const maxDataSize = VAULT_CONFIG.FIXED_SIZE - overhead;
    
    const prozent = Math.min(100, (bytesUsed / maxDataSize) * 100);
    const freiKB = Math.max(0, (maxDataSize - bytesUsed) / 1024);
    const belegtKB = bytesUsed / 1024;
    
    return {
      bytesUsed,
      maxDataSize,
      prozent: prozent.toFixed(1),
      freiKB: freiKB.toFixed(0),
      belegtKB: belegtKB.toFixed(0),
      istKritisch: prozent > 90,
      istWarnung: prozent > 75
    };
  }, [appState]);
  
  // Lokale UI-States
  const [activeTab, setActiveTab] = useState("material");
  const [suchTerm, setSuchTerm] = useState("");
  const [dokSuchTerm, setDokSuchTerm] = useState("");
  const [musterFilter, setMusterFilter] = useState(false);
  const [belegSort, setBelegSort] = useState("datum-desc");
  const [dokTypFilter, setDokTypFilter] = useState("alle");
  const [successMessage, setSuccessMessage] = useState("");
  const [neuMat, setNeuMat] = useState({ name: "", einheit: "Stk", preis: "0,00" });
  const [neuKunde, setNeuKunde] = useState({ anrede: "Organisation", name: "", strasse: "", plz: "", ort: "" });
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [clickedMaterial, setClickedMaterial] = useState(null);
  const [clickedKunde, setClickedKunde] = useState(null);
  
  const logoInputRef = useRef(null);
  
  // Standard-Dokumentstruktur fÃ¼r neues Dokument
  const leeresDokument = {
    id: null,
    typ: "RECHNUNG",
    nummer: "",
    datum: new Date().toLocaleDateString('de-DE'),
    leistungszeitraum: { von: "", bis: "" },
    kunde: { name: "", strasse: "", plz: "", ort: "" },
    positionen: [],
    abschlag: "0",
    muster: false,
    arbeitsort: "",
    abschlagsrechnungBetrag: "0",
    rabatt: "0",
    rabattBeschreibung: "Nachlass",
    betreff: "",
    freitext: "",
    signaturKunde: false,
    signaturAbsender: false,
    signaturAbsenderData: "",
    signaturAbsenderOrt: "",
    signaturAbsenderDatum: "",
    rechnungshinweis: ""
  };
  
  // Generiere temporÃ¤re ID fÃ¼r EntwÃ¼rfe (negativ, um von gespeicherten Dokumenten zu unterscheiden)
  const generateEntwurfId = () => -Date.now();
  
  // Lade ersten Entwurf oder leeres Dokument
  const [aktivesDok, setAktivesDok] = useState(() => {
    const entwuerfe = appState.entwuerfe || [];
    return entwuerfe.length > 0 ? entwuerfe[0] : { ...leeresDokument, entwurfId: generateEntwurfId() };
  });
  
  // PrÃ¼ft ob das aktuelle Dokument ECHTE Ã„nderungen hat (nicht nur auto-generierte Nummer)
  // Ein Entwurf gilt als "in Bearbeitung" wenn: Positionen, Kunde oder Betreff vorhanden
  const hatUngespeichertenEntwurf = React.useMemo(() => {
    return (aktivesDok.positionen?.length > 0) || 
      ((aktivesDok.kunde?.name || '').trim() !== '') ||
      ((aktivesDok.betreff || '').trim() !== '');
  }, [aktivesDok.positionen?.length, aktivesDok.kunde?.name, aktivesDok.betreff]);
  
  // Speichere Entwurf automatisch bei Ã„nderungen
  useEffect(() => {
    // Nur speichern wenn: Hat Ã„nderungen UND hat eine Entwurf-ID
    if (hatUngespeichertenEntwurf && aktivesDok.entwurfId) {
      console.log('ğŸ“ Entwurf wird gespeichert:', aktivesDok.kunde?.name, 'ID:', aktivesDok.entwurfId);
      updateState(prev => {
        const entwuerfe = prev.entwuerfe || [];
        const existingIndex = entwuerfe.findIndex(e => e.entwurfId === aktivesDok.entwurfId);
        
        if (existingIndex >= 0) {
          // Existierenden Entwurf aktualisieren
          const neueEntwuerfe = [...entwuerfe];
          neueEntwuerfe[existingIndex] = { ...aktivesDok };
          return { ...prev, entwuerfe: neueEntwuerfe };
        } else {
          // Neuen Entwurf hinzufÃ¼gen
          console.log('ğŸ“ Neuer Entwurf hinzugefÃ¼gt');
          return { ...prev, entwuerfe: [...entwuerfe, { ...aktivesDok }] };
        }
      });
    }
  }, [aktivesDok, hatUngespeichertenEntwurf, updateState]);
  
  // Browser-Warnung NUR wenn Vault noch speichert (pending/saving)
  // Der Entwurf wird ja automatisch im Vault gespeichert, daher keine Warnung nÃ¶tig
  useEffect(() => {
    const handleBeforeUnload = (e) => {
      // Warnung NUR wenn Vault noch nicht fertig gespeichert hat
      if (saveStatus === 'pending' || saveStatus === 'saving') {
        e.preventDefault();
        e.returnValue = 'Ã„nderungen werden noch gespeichert. Wirklich verlassen?';
        return e.returnValue;
      }
    };
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [saveStatus, hatUngespeichertenEntwurf]);

  // Signatur-Canvas Refs und Funktionen
  const signaturCanvasRef = useRef(null);
  const [isDrawing, setIsDrawing] = useState(false);

  const startDrawing = (e) => {
    const canvas = signaturCanvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
    const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
    ctx.beginPath();
    ctx.moveTo(x, y);
    setIsDrawing(true);
  };

  const draw = (e) => {
    if (!isDrawing) return;
    const canvas = signaturCanvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
    const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
    ctx.lineTo(x, y);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.stroke();
  };

  const stopDrawing = () => {
    if (isDrawing) {
      setIsDrawing(false);
      const canvas = signaturCanvasRef.current;
      if (canvas) {
        const dataUrl = canvas.toDataURL('image/png');
        setAktivesDok(prev => ({...prev, signaturAbsenderData: dataUrl}));
      }
    }
  };

  const clearSignaturCanvas = () => {
    const canvas = signaturCanvasRef.current;
    if (canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      setAktivesDok(prev => ({...prev, signaturAbsenderData: ''}));
    }
  };

  // Firmeneinstellungen speichern (in Vault)
  const saveFirmenDaten = (newData) => {
    const dataWithId = { ...newData, id: 1 };
    updateState(prev => ({
      ...prev,
      firmenDaten: dataWithId
    }));
  };

  // Logo hochladen
  const handleLogoUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      saveFirmenDaten({...firmenDaten, logo: ev.target.result});
    };
    reader.readAsDataURL(file);
  };

  const Ã¼bersetzeAnrede = w => {
    w = (w || "").toLowerCase().trim();
    if (w.includes('herr') || w === 'm') return "Herr";
    if (w.includes('frau') || w === 'w') return "Frau";
    return "Organisation";
  };

  // Zeige Namen wie sie sind
  const korrigiereName = (name, isOrganisation = false) => {
    return name;
  };

  // Generiere vorgeschlagene Rechnungsnummer beim ersten Laden
  useEffect(() => {
    const prefix = "RE";
    const existing = rechnungen
      .filter(d => d.typ === "RECHNUNG" && !d.muster)
      .map(d => {
        const match = d.nummer.match(/RE-(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
      });
    const nextNum = existing.length ? Math.max(...existing) + 1 : 1;
    const suggestedNumber = `${prefix}-${nextNum.toString().padStart(4, '0')}`;
    
    setAktivesDok(prev => ({...prev, nummer: suggestedNumber}));
  }, []);

  // Automatisch neue Nummer vorschlagen, wenn Dokumenttyp geÃ¤ndert wird
  useEffect(() => {
    if (aktivesDok.id) return; // Nur bei neuen Dokumenten
    
    const prefix = aktivesDok.typ === "ANGEBOT" ? "AN" : aktivesDok.typ === "ABSCHLAGSRECHNUNG" ? "AR" : aktivesDok.typ === "LEERES_DOKUMENT" ? "LD" : "RE";
    const existing = rechnungen
      .filter(d => d.typ === aktivesDok.typ && !d.muster)
      .map(d => {
        const match = d.nummer.match(new RegExp(`${prefix}-(\\d+)`));
        return match ? parseInt(match[1], 10) : 0;
      });
    const nextNum = existing.length ? Math.max(...existing) + 1 : 1;
    const suggestedNumber = `${prefix}-${nextNum.toString().padStart(4, '0')}`;
    
    setAktivesDok(prev => ({...prev, nummer: suggestedNumber}));
  }, [aktivesDok.typ]);

  // Datenbank speichern (im Vault)
  const saveToDB = (ndb) => {
    updateState(prev => ({
      ...prev,
      kunden: ndb.kunden,
      material: ndb.material
    }));
  };

  const generateNextNumber = () => {
    const prefix = aktivesDok.typ === "ANGEBOT" ? "AN" : aktivesDok.typ === "ABSCHLAGSRECHNUNG" ? "AR" : aktivesDok.typ === "LEERES_DOKUMENT" ? "LD" : "RE";
    const existing = rechnungen
      .filter(d => d.typ === aktivesDok.typ && !d.muster)
      .map(d => {
        const match = d.nummer.match(new RegExp(`${prefix}-(\\d+)`));
        return match ? parseInt(match[1], 10) : 0;
      });
    const next = existing.length ? Math.max(...existing) + 1 : 1;
    return `${prefix}-${next.toString().padStart(4, '0')}`;
  };

  const generateMusterNumber = () => {
    const prefix = aktivesDok.typ === "ANGEBOT" ? "AN" : aktivesDok.typ === "ABSCHLAGSRECHNUNG" ? "AR" : aktivesDok.typ === "LEERES_DOKUMENT" ? "LD" : "RE";
    const count = rechnungen.filter(d => d.muster && d.typ === aktivesDok.typ).length + 1;
    return `M-${prefix}-${count.toString().padStart(3, '0')}`;
  };

  const saveDok = (forceMuster = false, silent = false) => {
    // Wenn ein Muster bearbeitet wird und NICHT als Muster gespeichert werden soll,
    // erstelle ein neues Dokument (Muster bleibt unverÃ¤ndert)
    const isEditingMuster = aktivesDok.muster && !forceMuster;
    
    // PrÃ¼fen ob das Dokument mit dieser ID noch existiert
    const existiertInListe = aktivesDok.id !== null && aktivesDok.id > 0 && rechnungen.some(d => d.id === aktivesDok.id);
    
    let nr = aktivesDok.nummer.trim();
    
    if (isEditingMuster) {
      // Muster wird als neues normales Dokument gespeichert
      nr = generateNextNumber(); // Neue Nummer generieren
    } else if (!nr) {
      nr = forceMuster ? generateMusterNumber() : generateNextNumber();
    }
    
    // Neue ID generieren wenn: Muster-Bearbeitung, keine ID vorhanden, oder ID existiert nicht mehr in Liste
    const brauchNeueId = isEditingMuster || !aktivesDok.id || aktivesDok.id < 0 || !existiertInListe;
    
    // entwurfId entfernen fÃ¼r gespeichertes Dokument
    const { entwurfId, ...dokOhneEntwurfId } = aktivesDok;
    
    const neu = {
      ...dokOhneEntwurfId,
      id: brauchNeueId ? Date.now() : aktivesDok.id,
      nummer: nr,
      // Bei Muster-Bearbeitung: muster auf false setzen
      muster: isEditingMuster ? false : (forceMuster || aktivesDok.muster)
    };
    
    // Bei Muster-Bearbeitung oder neuem Dokument: hinzufÃ¼gen
    // Bei existierendem Dokument: aktualisieren
    const allDocs = brauchNeueId
      ? [...rechnungen, neu]  // Neues Dokument hinzufÃ¼gen
      : rechnungen.map(d => d.id === aktivesDok.id ? neu : d);  // Existierendes aktualisieren
    
    // Aktualisiere auch aktivesDok mit der neuen ID (ohne entwurfId)
    setAktivesDok(neu);
    
    // Speichere Rechnungen und Angebote getrennt im Vault
    const rechnungenItems = allDocs.filter(d => d.typ !== "ANGEBOT");
    const angeboteItems = allDocs.filter(d => d.typ === "ANGEBOT");
    
    // Entwurf aus der Liste entfernen (falls vorhanden)
    updateState(prev => {
      const entwuerfe = (prev.entwuerfe || []).filter(e => e.entwurfId !== entwurfId);
      return {
        ...prev,
        rechnungen: rechnungenItems,
        angebote: angeboteItems,
        entwuerfe: entwuerfe
      };
    });
    
    if (neu.muster) setMusterFilter(true);
    if (isEditingMuster) setMusterFilter(false); // Zeige normale Dokumente nach Muster-Konvertierung
    if (!silent) alert(`${neu.muster ? "Muster" : neu.typ} ${neu.nummer} gespeichert`);
  };

  const loadDok = d => {
    // Wenn Dokument aus gespeicherter Liste geladen wird, entwurfId entfernen
    const { entwurfId, ...dokOhneEntwurfId } = d;
    setAktivesDok(dokOhneEntwurfId);
  };

  const newDok = () => {
    // Generiere vorgeschlagene Nummer basierend auf Dokumenttyp
    const prefix = "RE";
    const existing = rechnungen
      .filter(d => d.typ === "RECHNUNG" && !d.muster)
      .map(d => {
        const match = d.nummer.match(/RE-(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
      });
    const nextNum = existing.length ? Math.max(...existing) + 1 : 1;
    const suggestedNumber = `${prefix}-${nextNum.toString().padStart(4, '0')}`;
    
    const neuesDok = {
      id: null,
      entwurfId: generateEntwurfId(), // Neue Entwurf-ID fÃ¼r automatisches Speichern
      typ: "RECHNUNG",
      nummer: suggestedNumber,
      datum: new Date().toLocaleDateString('de-DE'),
      leistungszeitraum: { von: "", bis: "" },
      kunde: { name: "", strasse: "", plz: "", ort: "" },
      positionen: [],
      abschlag: "0",
      muster: false,
      arbeitsort: "",
      abschlagsrechnungBetrag: "0",
      rabatt: "0",
      rabattBeschreibung: "Nachlass",
      betreff: "",
      freitext: "",
      signaturKunde: false,
      signaturAbsender: false,
      signaturAbsenderData: "",
      signaturAbsenderOrt: "",
      signaturAbsenderDatum: "",
      rechnungshinweis: ""
    };
    setAktivesDok(neuesDok);
  };

  const copyAsMuster = d => {
    const kopie = {
      ...d,
      id: null,
      nummer: generateMusterNumber(),
      datum: new Date().toLocaleDateString('de-DE'),
      muster: true
    };
    setAktivesDok(kopie);
    saveDok(true);
  };

  const removeMuster = (d) => {
    if (!confirm(`Muster ${d.nummer} in normales Dokument umwandeln?`)) return;
    
    const allDocs = rechnungen.map(doc => doc.id === d.id ? {...doc, muster: false} : doc);
    const rechnungenItems = allDocs.filter(doc => doc.typ !== "ANGEBOT");
    const angeboteItems = allDocs.filter(doc => doc.typ === "ANGEBOT");
    
    updateState(prev => ({
      ...prev,
      rechnungen: rechnungenItems,
      angebote: angeboteItems
    }));
    
    alert(`${d.typ} ${d.nummer} ist jetzt kein Muster mehr`);
    setMusterFilter(false);
  };

  const deleteDok = (d) => {
    if (!confirm(`${d.typ} ${d.nummer} wirklich lÃ¶schen? Diese Aktion kann nicht rÃ¼ckgÃ¤ngig gemacht werden.`)) return;
    
    const allDocs = rechnungen.filter(doc => doc.id !== d.id);
    const rechnungenItems = allDocs.filter(doc => doc.typ !== "ANGEBOT");
    const angeboteItems = allDocs.filter(doc => doc.typ === "ANGEBOT");
    
    updateState(prev => ({
      ...prev,
      rechnungen: rechnungenItems,
      angebote: angeboteItems
    }));
    
    alert(`${d.typ} ${d.nummer} wurde gelÃ¶scht`);
  };

  const updateStamm = (typ, kundeId, feld, val) => {
    const arr = [...db[typ]];
    const idx = arr.findIndex(item => item.id === kundeId);
    if (idx === -1) return;
    
    arr[idx] = { ...arr[idx], [feld]: val };
    saveToDB({ ...db, [typ]: arr });
    
    // Erfolgsmeldung anzeigen (nur Material)
    if (typ === "material") {
      setSuccessMessage(`âœ“ Ã„nderung gespeichert`);
      setTimeout(() => setSuccessMessage(""), 2000);
    }
    
    // Wenn ein Kunde bearbeitet wird, synchronisiere auch aktivesDok
    if (typ === "kunden") {
      const editedKunde = arr[idx];
      // PrÃ¼fe, ob dieser Kunde im aktiven Dokument verwendet wird (anhand des Namens)
      const kundenName = editedKunde.Organisation || editedKunde.name || "";
      if (aktivesDok.kunde.name && aktivesDok.kunde.name.includes(kundenName)) {
        // Aktualisiere die Adresse in aktivesDok
        setAktivesDok({
          ...aktivesDok,
          kunde: {
            ...aktivesDok.kunde,
            strasse: editedKunde.Strasse || editedKunde.strasse || "",
            plz: editedKunde.PLZ || editedKunde.plz || "",
            ort: editedKunde.Ort || editedKunde.ort || ""
          }
        });
      }
    }
  };

  // Hilfsfunktion: PrÃ¼ft ob aktives Dokument ein gespeichertes ist (nicht Entwurf)
  const istGespeichertesDokument = aktivesDok.id && aktivesDok.id > 0 && !aktivesDok.entwurfId;
  
  // Hilfsfunktion: Erstellt Kopie als neuen Entwurf
  const erstelleKopieAlsEntwurf = () => {
    const prefix = aktivesDok.typ === "ANGEBOT" ? "AN" : aktivesDok.typ === "ABSCHLAGSRECHNUNG" ? "AR" : aktivesDok.typ === "LEERES_DOKUMENT" ? "LD" : "RE";
    const existing = rechnungen
      .filter(d => d.typ === aktivesDok.typ && !d.muster)
      .map(d => {
        const match = d.nummer.match(new RegExp(`${prefix}-(\\d+)`));
        return match ? parseInt(match[1], 10) : 0;
      });
    const nextNum = existing.length ? Math.max(...existing) + 1 : 1;
    const suggestedNumber = `${prefix}-${nextNum.toString().padStart(4, '0')}`;
    
    return {
      ...aktivesDok,
      id: null,
      entwurfId: generateEntwurfId(),
      nummer: suggestedNumber,
      datum: new Date().toLocaleDateString('de-DE'),
      muster: false
    };
  };

  const waehleKunde = k => {
    const anrede = Ã¼bersetzeAnrede(k.anrede);
    const prfx = anrede === "Herr" ? "Herrn " : anrede === "Frau" ? "Frau " : "";
    const rawName = k.Organisation || k.name || "";
    const isOrg = !!k.Organisation;
    const correctedName = korrigiereName(rawName, isOrg);
    
    const neuerKunde = {
      name: prfx + correctedName,
      strasse: k.Strasse || k.strasse || "",
      plz: k.PLZ || k.plz || "",
      ort: k.Ort || k.ort || ""
    };
    
    // Wenn gespeichertes Dokument: Warnung anzeigen
    if (istGespeichertesDokument) {
      const alterKunde = aktivesDok.kunde?.name || 'Unbekannt';
      const choice = confirm(
        `âš ï¸ Sie bearbeiten ein gespeichertes Dokument!\n\n` +
        `${aktivesDok.typ} ${aktivesDok.nummer} (${alterKunde})\n\n` +
        `Was mÃ¶chten Sie tun?\n\n` +
        `[OK] = Neues Dokument mit "${correctedName}" erstellen\n` +
        `[Abbrechen] = Abbrechen (nichts Ã¤ndern)`
      );
      
      if (choice) {
        // Neues Dokument als Kopie erstellen
        const kopie = erstelleKopieAlsEntwurf();
        setAktivesDok({
          ...kopie,
          kunde: neuerKunde
        });
      }
      // Bei Abbrechen: Nichts tun
      return;
    }
    
    // Normaler Fall: Einfach Kunde setzen
    setAktivesDok({
      ...aktivesDok,
      kunde: neuerKunde
    });
  };

  const addPos = m => {
    const neuePosition = {
      id: Date.now(),
      name: m.Name,
      menge: "1",
      einheit: m.Einheit,
      preis: String(m.Verkaufspreis).replace('.', ','),
      isUeberschrift: false,
      isOptional: false
    };
    
    // Wenn gespeichertes Dokument: Warnung anzeigen
    if (istGespeichertesDokument) {
      const choice = confirm(
        `âš ï¸ Sie bearbeiten ein gespeichertes Dokument!\n\n` +
        `${aktivesDok.typ} ${aktivesDok.nummer}\n\n` +
        `Was mÃ¶chten Sie tun?\n\n` +
        `[OK] = Position zu neuem Dokument (Kopie) hinzufÃ¼gen\n` +
        `[Abbrechen] = Position zum Original hinzufÃ¼gen (Ã¼berschreibt!)`
      );
      
      if (choice) {
        // Neues Dokument als Kopie erstellen mit neuer Position
        const kopie = erstelleKopieAlsEntwurf();
        setAktivesDok({
          ...kopie,
          positionen: [...kopie.positionen, neuePosition]
        });
        return;
      }
      // Bei Abbrechen: Original wird bearbeitet (falls gewÃ¼nscht)
    }
    
    // Normaler Fall: Position hinzufÃ¼gen
    setAktivesDok({
      ...aktivesDok,
      positionen: [...aktivesDok.positionen, neuePosition]
    });
  };

  const parseVal = v => parseFloat(String(v || "0").replace(',', '.') || 0);

  const netto = aktivesDok.positionen.reduce((s, p) => (p.isUeberschrift || p.isOptional) ? s : s + parseVal(p.menge) * parseVal(p.preis), 0);
  const abschlagProzent = parseVal(aktivesDok.abschlag);
  const abschlagBetrag = netto * (abschlagProzent / 100);
  const restNetto = netto - abschlagBetrag;
  
  // Rabatt vom Netto abziehen
  const rabattBetrag = parseVal(aktivesDok.rabatt || "0");
  const nettoNachRabatt = restNetto - rabattBetrag;
  
  // MwSt auf Netto nach Rabatt berechnen
  const mwst = nettoNachRabatt * 0.19;
  const restBrutto = nettoNachRabatt + mwst;
  const brutto = nettoNachRabatt + mwst;
  
  // Manuell eingetragener Abschlagsrechnungsbetrag
  const abschlagsrechnungBetrag = parseVal(aktivesDok.abschlagsrechnungBetrag || "0");
  const restbetragNachAbschlag = brutto - abschlagsrechnungBetrag;

  const sortedRechnungen = [...rechnungen]
    .filter(d => musterFilter ? d.muster : !d.muster)
    .filter(d => {
      if (dokTypFilter === "alle") return true;
      if (dokTypFilter === "angebote") return d.typ === "ANGEBOT";
      if (dokTypFilter === "rechnungen") return d.typ === "RECHNUNG" || d.typ === "ABSCHLAGSRECHNUNG";
      if (dokTypFilter === "leer") return d.typ === "LEERES_DOKUMENT";
      return true;
    })
    .filter(d => {
      if (!dokSuchTerm) return true;
      const searchLower = dokSuchTerm.toLowerCase();
      return (d.nummer || "").toLowerCase().includes(searchLower) ||
             (d.kunde.name || "").toLowerCase().includes(searchLower) ||
             (d.datum || "").includes(searchLower);
    })
    .sort((a, b) => {
      if (belegSort === "datum-desc") return new Date(b.datum.split('.').reverse().join('-')) - new Date(a.datum.split('.').reverse().join('-'));
      if (belegSort === "datum-asc") return new Date(a.datum.split('.').reverse().join('-')) - new Date(b.datum.split('.').reverse().join('-'));
      if (belegSort === "nummer-desc") return (b.nummer || "").localeCompare(a.nummer || "");
      if (belegSort === "nummer-asc") return (a.nummer || "").localeCompare(b.nummer || "");
      return 0;
    });

  // Save Status Indicator
  const SaveStatusIndicator = () => {
    const statusColors = {
      saved: '#22c55e',
      pending: '#eab308',
      saving: '#3b82f6',
      error: '#ef4444'
    };
    const statusTexts = {
      saved: 'âœ“ Gespeichert',
      pending: 'â— Ã„nderungen...',
      saving: 'â†» Speichert...',
      error: 'âš  Fehler'
    };
    
    // Cloud-Sync Status
    const cloudStatusColors = {
      idle: '#64748b',
      uploading: '#8b5cf6',
      success: '#22c55e',
      error: '#ef4444'
    };
    const cloudStatusIcons = {
      idle: 'â˜ï¸',
      uploading: 'â—Œ',
      success: 'âœ“',
      error: 'âœ—'
    };
    
    return (
      <div style={{ 
        display: 'flex', 
        alignItems: 'center', 
        gap: '8px', 
        fontSize: '10px',
        padding: '4px 8px',
        background: 'rgba(0,0,0,0.3)',
        borderRadius: '4px'
      }}>
        <span style={{ color: statusColors[saveStatus] }}>{statusTexts[saveStatus]}</span>
        {lastSaved && saveStatus === 'saved' && (
          <span style={{ color: '#64748b' }}>
            {lastSaved.toLocaleTimeString('de-DE')}
          </span>
        )}
        {cloudConfig.enabled && (
          <span style={{ 
            color: cloudStatusColors[syncStatus], 
            marginLeft: '4px',
            borderLeft: '1px solid #475569',
            paddingLeft: '8px'
          }}>
            {cloudStatusIcons[syncStatus]} Cloud
          </span>
        )}
      </div>
    );
  };

  // ============================================================
  // ZENTRALE PDF-RENDER-FUNKTION - wird von allen PDF-Exports genutzt
  // ============================================================
  const renderPDFContent = (doc, dokument, firma, berechnungen) => {
    const { restNetto, nettoNachRabatt, mwst, brutto, abschlagProzent, abschlagBetrag, restBrutto } = berechnungen;
    
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const ml = 25;
    const mr = 20;
    const mt = 25;
    const mb = 45;
    const headerOffset = mt + 28;

    const addHeader = (pageNum = 1) => {
      const hexColor = firma.primaerFarbe || "#006666";
      const r = parseInt(hexColor.slice(1,3), 16);
      const g = parseInt(hexColor.slice(3,5), 16);
      const b = parseInt(hexColor.slice(5,7), 16);
      
      if (firma.logo) {
        const logoWidth = firma.logoBreite || 40;
        const logoHeight = firma.logoHoehe || 15;
        let logoX = ml;
        if (firma.logoPosition === "mitte") logoX = (pageWidth - logoWidth) / 2;
        else if (firma.logoPosition === "rechts") logoX = pageWidth - mr - logoWidth;
        try { doc.addImage(firma.logo, 'AUTO', logoX, mt - 10, logoWidth, logoHeight); } catch(e) {}
      }
      
      doc.setFontSize(28);
      doc.setFont("helvetica", "bold");
      doc.setTextColor(r, g, b);
      if (!firma.logo) {
        doc.text(firma.firmenname.toUpperCase(), pageWidth / 2, mt - 2, { align: "center" });
      }

      if (pageNum === 1) {
        doc.setFontSize(7);
        const bkColor = firma.briefkopfFarbe || "#444444";
        doc.setTextColor(parseInt(bkColor.slice(1,3), 16), parseInt(bkColor.slice(3,5), 16), parseInt(bkColor.slice(5,7), 16));
        doc.setFont("helvetica", "normal");
        const absenderName = firma.briefkopfAbsender === "firmenname" ? firma.firmenname : firma.inhaberName;
        const absender = `${absenderName} Â· ${firma.strasse} Â· ${firma.plz} ${firma.ort}`;
        doc.text(absender, ml, mt + 27);
        doc.setDrawColor(204, 204, 204);
        doc.line(ml, mt + 29, ml + doc.getTextWidth(absender), mt + 29);
      }
    };

    const addFooter = (pageNum, totalPages) => {
      let fy = pageHeight - mb + 12;
      doc.setDrawColor(204, 204, 204);
      doc.line(ml, fy + 5, pageWidth - mr, fy + 5);

      const colW = (pageWidth - ml - mr) / 4;
      const colsX = [ml, ml + colW, ml + colW * 2, ml + colW * 3];
      const emailLines = doc.splitTextToSize("E-Mail: " + firma.email, colW - 2);
      const colLines = [
        [firma.firmenname, firma.strasse, firma.plz + " " + firma.ort, firma.land],
        ["Tel. " + firma.telefon, ...emailLines, "Web: " + firma.website],
        ["Steuer-Nr. " + firma.steuernummer, "Inhaber: " + firma.inhaberName],
        ["Bank: " + firma.bankName, "IBAN: " + firma.iban, "BIC: " + firma.bic]
      ];

      doc.setFontSize(8.5);
      doc.setTextColor(68, 68, 68);
      let maxLines = Math.max(...colLines.map(c => c.length));
      let lineY = fy + 8;
      for (let i = 0; i < maxLines; i++) {
        for (let c = 0; c < 4; c++) {
          const txt = colLines[c][i];
          if (txt) doc.text(txt, colsX[c], lineY);
        }
        lineY += 3.8;
      }

      doc.setFontSize(9);
      doc.setTextColor(100);
      const pText = `Seite ${pageNum} von ${totalPages}`;
      doc.text(pText, pageWidth - mr - doc.getTextWidth(pText), pageHeight - 10);
    };

    let y = mt + 34;
    addHeader(1);

    // Anschrift
    doc.setFontSize(11);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(17, 17, 17);
    if (dokument.kunde?.name) { doc.text(dokument.kunde.name, ml, y); y += 5; }
    doc.setFont("helvetica", "normal");
    if (dokument.kunde?.strasse) { doc.text(dokument.kunde.strasse, ml, y); y += 5; }
    const plzOrt = [dokument.kunde?.plz, dokument.kunde?.ort].filter(Boolean).join(" ");
    if (plzOrt) { doc.text(plzOrt, ml, y); y += 5; }
    y += 24;

    // Titel
    doc.setFontSize(18);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(0, 102, 102);
    const titelText = dokument.typ === "LEERES_DOKUMENT" ? (dokument.betreff || "LEERES DOKUMENT") : (dokument.typ || "RECHNUNG");
    doc.text(titelText, ml, y);

    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(17, 17, 17);
    const numLabel = dokument.typ === "ANGEBOT" ? "Angebots-Nr." : dokument.typ === "ABSCHLAGSRECHNUNG" ? "Abschlagsrechnungs-Nr." : dokument.typ === "LEERES_DOKUMENT" ? "Dok.-Nr." : "Rechnungs-Nr.";
    doc.text(`${numLabel}: ${dokument.nummer || "â€“"}`, pageWidth - mr, y - 4, { align: "right" });
    doc.text(`Datum: ${dokument.datum || "â€“"}`, pageWidth - mr, y, { align: "right" });
    
    if (dokument.typ !== "ANGEBOT" && dokument.typ !== "LEERES_DOKUMENT" && (dokument.leistungszeitraum?.von || dokument.leistungszeitraum?.bis)) {
      const lzVon = dokument.leistungszeitraum.von || "";
      const lzBis = dokument.leistungszeitraum.bis || "";
      const lzText = lzVon && lzBis ? `${lzVon} - ${lzBis}` : lzVon || lzBis;
      doc.text(`Leistungszeitraum: ${lzText}`, pageWidth - mr, y + 5, { align: "right" });
    }
    y += 12;

    // LEERES_DOKUMENT Spezialbehandlung
    if (dokument.typ === "LEERES_DOKUMENT") {
      if (dokument.freitext) {
        doc.setFontSize(11);
        doc.setTextColor(17, 17, 17);
        const freitextLines = doc.splitTextToSize(dokument.freitext, pageWidth - ml - mr);
        for (const ln of freitextLines) {
          if (y > pageHeight - mb) { doc.addPage(); addHeader(doc.internal.getNumberOfPages()); y = headerOffset; }
          doc.text(ln, ml, y);
          y += 6;
        }
      }
      
      const hasSignatur = dokument.signaturKunde || dokument.signaturAbsender;
      if (hasSignatur) {
        y += 15;
        if (y + 35 > pageHeight - mb) { doc.addPage(); addHeader(doc.internal.getNumberOfPages()); y = headerOffset + 15; }
        const bothSignatures = dokument.signaturKunde && dokument.signaturAbsender;
        const sigWidth = 60, sigGap = 20;
        let xAbsender = ml;
        let xKunde = bothSignatures ? ml + sigWidth + sigGap : ml;
        
        if (dokument.signaturAbsender) {
          doc.setFontSize(9); doc.setTextColor(102, 102, 102);
          doc.text(firma.inhaberName, xAbsender, y);
          if (dokument.signaturAbsenderData) {
            try { doc.addImage(dokument.signaturAbsenderData, 'PNG', xAbsender, y + 2, sigWidth, 20); } catch(e) {}
          }
          doc.setDrawColor(51, 51, 51); doc.setLineWidth(0.3);
          doc.line(xAbsender, y + 24, xAbsender + sigWidth, y + 24);
          doc.setFontSize(8); doc.setTextColor(153, 153, 153);
          doc.text("Ort, Datum: " + (dokument.signaturAbsenderOrt || "________________") + ", " + (dokument.signaturAbsenderDatum || "________________"), xAbsender, y + 28);
        }
        
        if (dokument.signaturKunde) {
          doc.setFontSize(9); doc.setTextColor(102, 102, 102);
          doc.text("Unterschrift Kunde", xKunde, y);
          doc.setDrawColor(51, 51, 51); doc.setLineWidth(0.3);
          doc.line(xKunde, y + 24, xKunde + sigWidth, y + 24);
          doc.setFontSize(8); doc.setTextColor(153, 153, 153);
          doc.text("Ort, Datum: ________________", xKunde, y + 28);
        }
      }
      
      const totalPages = doc.internal.getNumberOfPages();
      for (let i = 1; i <= totalPages; i++) { doc.setPage(i); addFooter(i, totalPages); }
      return;
    }

    // Arbeitsort
    const workText = dokument.arbeitsort || (dokument.typ === "ANGEBOT"
      ? (dokument.kunde?.strasse && dokument.kunde?.ort ? `FÃ¼r die Arbeiten in der ${dokument.kunde.strasse} in ${dokument.kunde.ort}.` : dokument.kunde?.strasse ? `FÃ¼r die Arbeiten in der ${dokument.kunde.strasse}.` : 'FÃ¼r die Arbeiten in der StraÃŸe des Kunden.')
      : (dokument.kunde?.strasse && dokument.kunde?.ort ? `FÃ¼r die ausgefÃ¼hrten Arbeiten in der ${dokument.kunde.strasse} in ${dokument.kunde.ort}.` : dokument.kunde?.strasse ? `FÃ¼r die ausgefÃ¼hrten Arbeiten in der ${dokument.kunde.strasse}.` : 'FÃ¼r die ausgefÃ¼hrten Arbeiten in der StraÃŸe des Kunden.'));
    const workLines = doc.splitTextToSize(workText, pageWidth - ml - mr);
    if (y + workLines.length * 5 > pageHeight - mb) { doc.addPage(); addHeader(doc.internal.getNumberOfPages()); y = headerOffset; }
    doc.setFontSize(10); doc.setTextColor(68, 68, 68);
    for (const ln of workLines) { doc.text(ln, ml, y); y += 5; }
    y += 4;

    // Tabelle
    let posCounter = 0;
    const tableBody = (dokument.positionen || []).map((p) => {
      let posNummer = "";
      if (!p.isUeberschrift) {
        if (p.isOptional) posNummer = "Opt.";
        else { posCounter++; posNummer = String(posCounter); }
      }
      const gesamtBetrag = (parseVal(p.menge) * parseVal(p.preis)).toFixed(2) + " â‚¬";
      const gesamtAnzeige = (p.isOptional && !p.isUeberschrift) ? `(${gesamtBetrag})` : gesamtBetrag;
      return [
        posNummer, p.name || "",
        p.isUeberschrift ? "" : (p.menge || ""),
        p.isUeberschrift ? "" : (p.einheit || ""),
        p.isUeberschrift ? "" : ((p.preis || "") + (p.preis ? " â‚¬" : "")),
        p.isUeberschrift ? "" : gesamtAnzeige
      ];
    });

    doc.autoTable({
      startY: y,
      head: [['Pos.', 'Beschreibung', 'Menge', 'Einheit', 'Einzelpreis â‚¬', 'Gesamt â‚¬']],
      body: tableBody,
      theme: 'plain',
      styles: { fontSize: 10, cellPadding: 2.8, overflow: 'linebreak', halign: 'left', lineWidth: {top: 0, right: 0, bottom: 0.1, left: 0}, lineColor: [238, 238, 238] },
      headStyles: { fillColor: false, textColor: [0, 102, 102], fontStyle: 'bold', lineWidth: {top: 0, right: 0, bottom: 0.3, left: 0}, lineColor: [0, 102, 102] },
      alternateRowStyles: { fillColor: false },
      columnStyles: { 0: { cellWidth: 14, halign: 'left' }, 1: { cellWidth: 'auto' }, 2: { cellWidth: 22, halign: 'right' }, 3: { cellWidth: 20, halign: 'right' }, 4: { cellWidth: 30, halign: 'right' }, 5: { cellWidth: 30, halign: 'right' } },
      margin: { left: ml, right: mr, bottom: mb, top: headerOffset },
      didParseCell: (data) => {
        if (data.section === 'body' && data.row.index < (dokument.positionen || []).length) {
          const pos = (dokument.positionen || [])[data.row.index];
          if (pos?.isUeberschrift) data.cell.styles.fontStyle = 'bold';
          else if (data.column.index === 5) data.cell.styles.fontStyle = 'bold';
        }
      },
      didDrawPage: () => { addHeader(doc.internal.getCurrentPageInfo().pageNumber); }
    });

    y = doc.lastAutoTable.finalY + 14;

    // Summenblock
    let sumHeight = 28;
    if (abschlagProzent > 0) sumHeight += 18;
    if (y + sumHeight > pageHeight - mb) { doc.addPage(); addHeader(doc.internal.getCurrentPageInfo().pageNumber); y = headerOffset; }

    const sumRight = pageWidth - mr;
    const sumLeft = sumRight - 85;

    doc.setFontSize(10); doc.setDrawColor(0, 102, 102); doc.setFont("helvetica", "normal"); doc.setTextColor(17, 17, 17);
    doc.setLineWidth(0.1); doc.line(sumLeft, y - 2, sumRight, y - 2); y += 2;
    doc.text('Nettobetrag', sumLeft, y);
    doc.text(restNetto.toFixed(2) + ' â‚¬', sumRight, y, { align: "right" });
    y += 5;

    const rabattBetrag = parseVal(dokument.rabatt || "0");
    if (rabattBetrag > 0) {
      doc.setTextColor(0, 102, 102);
      doc.text(dokument.rabattBeschreibung || "Nachlass", sumLeft, y);
      doc.text(`-${rabattBetrag.toFixed(2)} â‚¬`, sumRight, y, { align: "right" });
      y += 4;
      doc.setTextColor(17, 17, 17); doc.setFont("helvetica", "bold");
      doc.setLineWidth(0.1); doc.line(sumLeft, y, sumRight, y); y += 3;
      doc.text('Zwischensumme', sumLeft, y);
      doc.text(nettoNachRabatt.toFixed(2) + ' â‚¬', sumRight, y, { align: "right" });
      y += 5; doc.setFont("helvetica", "normal");
    }

    doc.setTextColor(17, 17, 17);
    doc.text('MwSt. 19 %', sumLeft, y);
    doc.text(mwst.toFixed(2) + ' â‚¬', sumRight, y, { align: "right" });
    y += 4;

    doc.setLineWidth(0.3); doc.line(sumLeft, y - 3, sumRight, y - 3); y += 4;
    doc.setFontSize(12); doc.setFont("helvetica", "bold");
    const sumLabel = dokument.typ === "ANGEBOT" ? "Angebotssumme" : dokument.typ === "ABSCHLAGSRECHNUNG" ? "Abschlagsrechnungsbetrag" : "Rechnungsbetrag";
    doc.text(sumLabel, sumLeft, y);
    doc.text(brutto.toFixed(2) + ' â‚¬', sumRight, y, { align: "right" });
    y += 4;

    if (dokument.typ === "RECHNUNG" && parseVal(dokument.abschlagsrechnungBetrag || "0") > 0) {
      const abschlagsrechnungBetrag = parseVal(dokument.abschlagsrechnungBetrag || "0");
      doc.setTextColor(0, 102, 102); doc.setFont("helvetica", "normal"); doc.setFontSize(10); y += 2;
      doc.text('Abzgl. Abschlagsrechnung(en)', sumLeft, y);
      doc.text(`-${abschlagsrechnungBetrag.toFixed(2)} â‚¬`, sumRight, y, { align: "right" });
      y += 5; doc.setTextColor(17, 17, 17); doc.setFontSize(13); doc.setFont("helvetica", "bold");
      doc.setLineWidth(0.1); doc.line(sumLeft, y, sumRight, y); y += 4;
      doc.text('Restbetrag', sumLeft, y);
      doc.text((brutto - abschlagsrechnungBetrag).toFixed(2) + ' â‚¬', sumRight, y, { align: "right" });
      y += 2;
    }

    if (abschlagProzent > 0) {
      y += 3; doc.setTextColor(0, 102, 102); doc.setFont("helvetica", "normal"); doc.setFontSize(10);
      doc.text(`Abschlag ${abschlagProzent} %`, sumLeft, y);
      doc.text(`-${abschlagBetrag.toFixed(2)} â‚¬`, sumRight, y, { align: "right" });
      y += 3; doc.setTextColor(17, 17, 17); doc.setFontSize(13); doc.setFont("helvetica", "bold");
      doc.setLineWidth(0.1); doc.setLineDash([1, 1]); doc.line(sumLeft, y, sumRight, y); y += 2;
      doc.text('Restbetrag', sumLeft, y);
      doc.text(restBrutto.toFixed(2) + ' â‚¬', sumRight, y, { align: "right" });
      doc.setLineDash([]);
    }

    // Zahlungsbedingungen
    const stundensatz = firma.stundensatz || 59;
    const zahlungsziel = firma.zahlungsziel || 10;
    const angebotsgueltigkeit = firma.angebotsgueltigkeit || 30;
    const paymentLines = dokument.typ === "ANGEBOT" ? [
      "", (firma.angebotHinweis || "Unvorhergesehene Arbeiten werden mit {stundensatz},- â‚¬/Std. abgerechnet.").replace('{stundensatz}', stundensatz),
      "", `Dieses Angebot ist ${angebotsgueltigkeit} Tage ab Ausstellungsdatum gÃ¼ltig.`,
      "", "Wir freuen uns auf Ihre Auftragserteilung und stehen fÃ¼r RÃ¼ckfragen gerne zur VerfÃ¼gung.",
      "", "Mit freundlichen GrÃ¼ÃŸen", firma.inhaberName
    ] : [
      "", `Zahlungsbedingungen: Zahlung innerhalb von ${zahlungsziel} Tagen ab Rechnungseingang ohne AbzÃ¼ge.`,
      "", ...(dokument.rechnungshinweis ? [dokument.rechnungshinweis, ""] : []),
      "Bitte Ã¼berweisen Sie den Rechnungsbetrag unter Angabe der Rechnungsnummer auf das unten angegebene Konto.",
      "", "Mit freundlichen GrÃ¼ÃŸen", firma.inhaberName
    ];

    const maxWidth = pageWidth - ml - mr;
    const paymentWrapped = paymentLines.map(l => doc.splitTextToSize(l, maxWidth));
    const paymentHeight = paymentWrapped.reduce((acc, arr) => acc + (arr.length * 5), 0);
    if (y + paymentHeight > pageHeight - mb) { doc.addPage(); addHeader(doc.internal.getNumberOfPages()); y = headerOffset; }

    y += 5; doc.setFontSize(10); doc.setTextColor(68, 68, 68);
    for (const wrapped of paymentWrapped) {
      for (const ln of wrapped) { doc.text(ln, ml, y); y += 5; }
    }

    // Footer auf alle Seiten
    const totalPages = doc.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) { doc.setPage(i); addFooter(i, totalPages); }
  };

  // ============================================================
  // HAUPT-PDF-EXPORT-FUNKTION
  // ============================================================
  const createPDF = async () => {
    saveDok();
    await forceSave();
    
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });

    // Berechnungen fÃ¼r PDF
    const berechnungen = { restNetto, nettoNachRabatt, mwst, brutto, abschlagProzent, abschlagBetrag, restBrutto };
    
    // Zentralisierte Render-Funktion aufrufen
    renderPDFContent(doc, aktivesDok, firmenDaten, berechnungen);

    // Dateiname generieren
    const fullName = aktivesDok.kunde?.name || "Unbekannt";
    const cleanName = fullName.replace(/^(Herr|Herrn|Frau|FrÃ¤ulein)\s+/i, "").trim();
    const lastName = cleanName.split(" ").pop().replace(/[^a-zA-Z0-9Ã¤Ã¶Ã¼ÃŸ-]/g, "");
    const fileName = `${aktivesDok.nummer}-${lastName}.pdf`;
    
    // Share/Download Dialog
    const pdfBlob = doc.output('blob');
    const file = new File([pdfBlob], fileName, { type: 'application/pdf' });
    
    const hasShare = typeof navigator.share === 'function';
    let canShareFiles = false;
    if (navigator.canShare) {
      try { canShareFiles = navigator.canShare({ files: [file] }); } catch(e) {}
    }
    
    if (hasShare && canShareFiles) {
      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;';
      overlay.innerHTML = `
        <div style="background:#1e293b;padding:30px;border-radius:15px;text-align:center;max-width:90%;color:white;">
          <h3 style="margin:0 0 10px 0;">ğŸ“„ ${fileName}</h3>
          <p style="margin:0 0 20px 0;color:#94a3b8;font-size:14px;">Wie mÃ¶chten Sie die PDF speichern?</p>
          <button id="sharePdfBtn2" style="background:#22c55e;color:white;border:none;padding:15px 40px;border-radius:10px;font-size:18px;cursor:pointer;margin:5px;min-width:140px;">ğŸ“¤ Teilen</button>
          <button id="downloadPdfBtn2" style="background:#3b82f6;color:white;border:none;padding:15px 40px;border-radius:10px;font-size:18px;cursor:pointer;margin:5px;min-width:140px;">ğŸ’¾ Download</button>
          <br><button id="cancelPdfBtn2" style="background:#64748b;color:white;border:none;padding:10px 30px;border-radius:8px;font-size:14px;cursor:pointer;margin-top:15px;">Abbrechen</button>
        </div>
      `;
      document.body.appendChild(overlay);
      overlay.querySelector('#sharePdfBtn2').onclick = async () => { overlay.remove(); try { await navigator.share({ files: [file], title: fileName }); } catch (err) { if (err.name !== 'AbortError') doc.save(fileName); } };
      overlay.querySelector('#downloadPdfBtn2').onclick = () => { overlay.remove(); doc.save(fileName); };
      overlay.querySelector('#cancelPdfBtn2').onclick = () => { overlay.remove(); };
    } else {
      doc.save(fileName);
    }
  };

  return (
    <div className="app-container flex flex-col md:flex-row h-screen overflow-hidden">
      {/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       * MOBILE HEADER - Nur auf Mobile sichtbar
       * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */}
      <div className="md:hidden fixed top-0 left-0 right-0 z-50 bg-slate-900 border-b border-slate-700 px-4 py-3 flex items-center justify-between">
        {/* Hamburger-MenÃ¼ */}
        <button
          onClick={() => setSidebarOpen(!sidebarOpen)}
          className="text-white p-2 rounded hover:bg-slate-700"
          title="MenÃ¼"
        >
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={sidebarOpen ? "M6 18L18 6M6 6l12 12" : "M4 6h16M4 12h16M4 18h16"} />
          </svg>
        </button>
        
        {/* Titel */}
        <span className="text-white font-bold text-sm">
          {aktivesDok.typ === 'ANGEBOT' ? 'ğŸ“‹ Angebot' : aktivesDok.typ === 'ABSCHLAGSRECHNUNG' ? 'ğŸ“‘ Abschlag' : 'ğŸ“„ Rechnung'} {aktivesDok.nummer}
        </span>
        
        {/* Status-Icons */}
        <div className="flex items-center gap-2">
          {/* Cloud-Status */}
          {cloudConfig.enabled && (
            <div className="relative" title={syncStatus === 'idle' ? 'Cloud bereit' : syncStatus === 'uploading' ? 'Synchronisiere...' : syncStatus === 'success' ? 'Cloud-Sync OK' : 'Cloud-Fehler'}>
              {syncStatus === 'idle' && <span className="text-slate-500 text-lg">â˜ï¸</span>}
              {syncStatus === 'uploading' && <span className="text-purple-400 text-lg animate-spin">âŸ³</span>}
              {syncStatus === 'success' && <span className="text-green-400 text-lg">â˜ï¸</span>}
              {syncStatus === 'error' && <span className="text-red-400 text-lg">â˜ï¸</span>}
            </div>
          )}
          
          {/* Save-Status */}
          <div className={`w-2.5 h-2.5 rounded-full ${
            saveStatus === 'saved' ? 'bg-green-500' : 
            saveStatus === 'pending' ? 'bg-orange-500 animate-pulse' : 
            saveStatus === 'saving' ? 'bg-blue-500 animate-ping' : 
            'bg-red-500'
          }`} />
          
          {/* Logout-Button */}
          <button
            onClick={async () => {
              if (saveStatus === 'pending' || saveStatus === 'saving') {
                if (!confirm('Ã„nderungen werden noch gespeichert. Trotzdem ausloggen?')) return;
              }
              await lockVault();
            }}
            className="text-slate-400 hover:text-red-400 p-1"
            title="Vault sperren"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
            </svg>
          </button>
        </div>
      </div>
      
      {/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       * DESKTOP STATUS BAR - Nur auf Desktop sichtbar (oben rechts)
       * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */}
      <div className="hidden md:flex fixed top-4 right-4 z-50 items-center gap-3">
        {/* Cloud-Status */}
        {cloudConfig.enabled && (
          <div className="flex items-center gap-2 bg-slate-800/90 backdrop-blur px-3 py-2 rounded-lg border border-slate-700" title={syncStatus === 'idle' ? 'Cloud bereit' : syncStatus === 'uploading' ? 'Synchronisiere...' : syncStatus === 'success' ? 'Cloud-Sync OK' : 'Cloud-Fehler'}>
            {syncStatus === 'idle' && <span className="text-slate-400 text-sm">â˜ï¸ Bereit</span>}
            {syncStatus === 'uploading' && <span className="text-purple-400 text-sm animate-pulse">âŸ³ Sync...</span>}
            {syncStatus === 'success' && <span className="text-green-400 text-sm">â˜ï¸ âœ“</span>}
            {syncStatus === 'error' && <span className="text-red-400 text-sm">â˜ï¸ âœ—</span>}
          </div>
        )}
        
        {/* Status-Indikator (Ampel) */}
        <div className="flex items-center gap-2 bg-slate-800/90 backdrop-blur px-3 py-2 rounded-lg border border-slate-700" title={saveStatus === 'saved' ? 'Alle Ã„nderungen gespeichert' : saveStatus === 'pending' ? 'Ã„nderungen werden gespeichert...' : saveStatus === 'saving' ? 'Speichert...' : 'Fehler beim Speichern'}>
          {saveStatus === 'saved' && (
            <>
              <span className="w-3 h-3 rounded-full bg-green-500 animate-pulse"></span>
              <span className="text-green-400 text-xs font-medium">âœ“ Gespeichert</span>
            </>
          )}
          {saveStatus === 'pending' && (
            <>
              <span className="w-3 h-3 rounded-full bg-orange-500 animate-pulse"></span>
              <span className="text-orange-400 text-xs font-medium">â— Ã„nderungen...</span>
            </>
          )}
          {saveStatus === 'saving' && (
            <>
              <span className="w-3 h-3 rounded-full bg-blue-500 animate-spin"></span>
              <span className="text-blue-400 text-xs font-medium">â†» Speichert...</span>
            </>
          )}
          {saveStatus === 'error' && (
            <>
              <span className="w-3 h-3 rounded-full bg-red-500"></span>
              <span className="text-red-400 text-xs font-medium">âœ— Fehler</span>
            </>
          )}
        </div>
        
        {/* Logout-Button (Schloss) */}
        <button
          onClick={async () => {
            if (saveStatus === 'pending' || saveStatus === 'saving') {
              if (!confirm('Ã„nderungen werden noch gespeichert. Trotzdem ausloggen?')) return;
            }
            await lockVault();
          }}
          className="bg-slate-800/90 backdrop-blur hover:bg-red-700 text-white p-2 rounded-lg border border-slate-700 hover:border-red-600 transition-colors"
          title="Vault sperren (Logout)"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
          </svg>
        </button>
      </div>
      
      {/* Sidebar Backdrop fÃ¼r Mobile */}
      <div className={`sidebar-backdrop ${sidebarOpen ? 'open' : ''}`} onClick={() => setSidebarOpen(false)}></div>
      
      <div className={`sidebar w-full md:w-96 bg-slate-900 text-white p-4 pt-16 md:pt-4 pb-24 md:pb-4 no-print flex flex-col shadow-2xl border-r border-teal-900 ${sidebarOpen ? 'open' : ''}`}>
        <div className="flex gap-1 mb-4 bg-slate-800 p-1 rounded text-[10px] font-bold uppercase flex-wrap">
          <button onClick={() => { setActiveTab("material"); setSuchTerm(""); }} className={`flex-1 py-2 rounded ${activeTab === "material" ? "bg-teal-600" : ""}`}>Positionen</button>
          <button onClick={() => { setActiveTab("kunden"); setSuchTerm(""); }} className={`flex-1 py-2 rounded ${activeTab === "kunden" ? "bg-teal-600" : ""}`}>Kunden</button>
          <button onClick={() => { setActiveTab("dokumente"); setSuchTerm(""); }} className={`flex-1 py-2 rounded ${activeTab === "dokumente" ? "bg-teal-600" : ""}`}>Dokumente</button>
          <button onClick={() => { setActiveTab("neu"); setSuchTerm(""); }} className={`flex-1 py-2 rounded ${activeTab === "neu" ? "bg-teal-600" : ""}`}>+ Neu</button>
          <button onClick={() => { setActiveTab("einstellungen"); setSuchTerm(""); }} className={`flex-1 py-2 rounded ${activeTab === "einstellungen" ? "bg-teal-600" : ""}`}>âš™ï¸</button>
        </div>

        <div className="flex-1 overflow-y-auto custom-scrollbar pr-2 space-y-4">
          {activeTab === "material" && (
            <>
              <h3 className="text-teal-400 font-bold uppercase text-xs mb-2">Positionen</h3>
              {successMessage && (
                <div style={{ backgroundColor: '#10b981', color: 'white', padding: '8px 12px', borderRadius: '4px', marginBottom: '12px', fontSize: '11px', fontWeight: 'bold', textAlign: 'center' }}>
                  {successMessage}
                </div>
              )}
              <input type="text" placeholder="Suchen..." className="w-full p-2 text-black text-xs rounded outline-none" value={suchTerm} onChange={e => setSuchTerm(e.target.value)} />
              {db.material.filter(m => (m.Name || "").toLowerCase().includes(suchTerm.toLowerCase())).map((m, i) => (
                <div key={m.id || i} className="p-2 bg-slate-800 rounded border border-slate-700 text-[10px] group">
                  <input className="bg-transparent text-teal-300 font-bold w-full outline-none" value={m.Name} onChange={e => updateStamm('material', m.id, 'Name', e.target.value)} />
                  <div className="flex justify-between mt-1 items-center">
                    <div className="flex gap-1 text-slate-400 italic">
                      <input className="bg-slate-700 w-16 px-1 rounded text-white" value={m.Verkaufspreis} onChange={e => updateStamm('material', m.id, 'Verkaufspreis', e.target.value)} /> â‚¬
                      <input className="bg-slate-700 w-10 px-1 rounded uppercase text-white" value={m.Einheit} onChange={e => updateStamm('material', m.id, 'Einheit', e.target.value)} />
                    </div>
                    <button onClick={() => { addPos(m); setClickedMaterial(m.id); setTimeout(() => setClickedMaterial(null), 300); }} className={`px-3 py-1 rounded font-bold uppercase text-xs transition-colors ${clickedMaterial === m.id ? 'bg-green-500 scale-95' : 'bg-teal-600'}`} style={{transform: clickedMaterial === m.id ? 'scale(0.95)' : 'scale(1)', transition: 'all 0.1s ease'}}>ADD</button>
                  </div>
                </div>
              ))}
            </>
          )}

          {activeTab === "kunden" && (
            <>
              <h3 className="text-teal-400 font-bold uppercase text-xs mb-2">Kunden</h3>
              <input type="text" placeholder="Kunden suchen..." className="w-full p-2 text-black text-xs rounded outline-none" value={suchTerm} onChange={e => setSuchTerm(e.target.value)} />
              {db.kunden.filter(k => (k.Organisation || k.name || "").toLowerCase().includes(suchTerm.toLowerCase())).map((k, i) => {
                const displayName = korrigiereName(k.Organisation || k.name || "", !!k.Organisation);
                return (
                <div key={k.id || i} className="p-3 bg-slate-800 rounded border border-slate-700 text-[10px] space-y-2">
                  <select value={k.anrede} onChange={e => updateStamm('kunden', k.id, 'anrede', e.target.value)} className="bg-slate-700 text-teal-300 rounded px-1 outline-none font-bold">
                    <option value="Organisation">Organisation</option>
                    <option value="Herr">Herr</option>
                    <option value="Frau">Frau</option>
                  </select>
                  <input className="bg-transparent text-white font-bold w-full outline-none text-xs border-b border-slate-700" placeholder="Name / Firma" value={displayName} onChange={e => updateStamm('kunden', k.id, 'Organisation', e.target.value)} />
                  <input className="bg-slate-700 text-white w-full outline-none text-xs rounded px-2 py-1" placeholder="StraÃŸe" value={k.Strasse || k.strasse || ""} onChange={e => updateStamm('kunden', k.id, 'Strasse', e.target.value)} />
                  <div className="flex gap-2">
                    <input className="bg-slate-700 text-white w-1/3 outline-none text-xs rounded px-2 py-1" placeholder="PLZ" value={k.PLZ || k.plz || ""} onChange={e => updateStamm('kunden', k.id, 'PLZ', e.target.value)} />
                    <input className="bg-slate-700 text-white w-2/3 outline-none text-xs rounded px-2 py-1" placeholder="Ort" value={k.Ort || k.ort || ""} onChange={e => updateStamm('kunden', k.id, 'Ort', e.target.value)} />
                  </div>
                  <button onClick={() => { waehleKunde(k); setClickedKunde(k.id); setTimeout(() => { setClickedKunde(null); setSidebarOpen(false); }, 300); }} className={`w-full py-1.5 rounded font-bold uppercase text-xs transition-colors ${clickedKunde === k.id ? 'bg-green-500 scale-95' : 'bg-teal-600'}`} style={{transform: clickedKunde === k.id ? 'scale(0.95)' : 'scale(1)', transition: 'all 0.1s ease'}}>WÃ¤hlen</button>
                </div>
              );})}
            </>
          )}

          {activeTab === "dokumente" && (
            <>
              <h3 className="text-teal-400 font-bold uppercase text-xs mb-2">Dokumente</h3>
              <input 
                type="text" 
                placeholder="Dokumente suchen (Nummer, Kunde, Datum)..." 
                className="w-full p-2 text-black text-xs rounded outline-none" 
                value={dokSuchTerm} 
                onChange={e => setDokSuchTerm(e.target.value)} 
              />
              <div className="flex gap-2 mb-2 mt-3">
                <select value={belegSort} onChange={e => setBelegSort(e.target.value)} className="bg-slate-700 text-white rounded px-2 py-1 text-xs">
                  <option value="datum-desc">Datum (neueste zuerst)</option>
                  <option value="datum-asc">Datum (Ã¤lteste zuerst)</option>
                  <option value="nummer-desc">Nummer (neueste zuerst)</option>
                  <option value="nummer-asc">Nummer (Ã¤lteste zuerst)</option>
                </select>
                <button onClick={() => setMusterFilter(!musterFilter)} className={`px-3 py-1 rounded text-xs font-bold ${musterFilter ? "bg-purple-600" : "bg-slate-700"}`}>
                  {musterFilter ? "Muster aus" : "Nur Muster"}
                </button>
              </div>
              <div className="flex gap-2 mb-2">
                <button onClick={() => setDokTypFilter("alle")} className={`flex-1 px-3 py-1 rounded text-xs font-bold ${dokTypFilter === "alle" ? "bg-teal-600" : "bg-slate-700"}`}>
                  Alle
                </button>
                <button onClick={() => setDokTypFilter("angebote")} className={`flex-1 px-3 py-1 rounded text-xs font-bold ${dokTypFilter === "angebote" ? "bg-blue-600" : "bg-slate-700"}`}>
                  Angebote
                </button>
                <button onClick={() => setDokTypFilter("rechnungen")} className={`flex-1 px-3 py-1 rounded text-xs font-bold ${dokTypFilter === "rechnungen" ? "bg-green-600" : "bg-slate-700"}`}>
                  Rechnungen
                </button>
                <button onClick={() => setDokTypFilter("leer")} className={`flex-1 px-3 py-1 rounded text-xs font-bold ${dokTypFilter === "leer" ? "bg-purple-600" : "bg-slate-700"}`}>
                  Leer
                </button>
                <button onClick={() => setDokTypFilter("entwuerfe")} className={`flex-1 px-3 py-1 rounded text-xs font-bold ${dokTypFilter === "entwuerfe" ? "bg-orange-600" : "bg-slate-700"}`}>
                  EntwÃ¼rfe {(appState.entwuerfe?.length || 0) > 0 && `(${appState.entwuerfe.length})`}
                </button>
              </div>
              
              {/* EntwÃ¼rfe-Ansicht */}
              {dokTypFilter === "entwuerfe" ? (
                <>
                  {(appState.entwuerfe?.length || 0) > 0 ? (
                    appState.entwuerfe.map(entwurf => (
                      <div key={entwurf.entwurfId} className="p-3 bg-slate-800 rounded border-2 border-orange-500 text-xs mb-2">
                        <div className="flex items-center gap-2 mb-2">
                          <span className="text-orange-400 font-bold text-sm">âš ï¸ ENTWURF</span>
                          {entwurf.entwurfId === aktivesDok.entwurfId && (
                            <span className="text-xs bg-green-600 px-2 py-0.5 rounded">AKTIV</span>
                          )}
                        </div>
                        <div className="text-slate-300 mb-1">
                          <span className="text-slate-500">Typ:</span> {entwurf.typ || 'Unbekannt'}
                        </div>
                        <div className="text-slate-300 mb-1">
                          <span className="text-slate-500">Kunde:</span> {entwurf.kunde?.name || 'Kein Kunde'}
                        </div>
                        <div className="text-slate-300 mb-1">
                          <span className="text-slate-500">Datum:</span> {entwurf.datum || 'Kein Datum'}
                        </div>
                        <div className="text-slate-300 mb-3">
                          <span className="text-slate-500">Positionen:</span> {entwurf.positionen?.length || 0}
                        </div>
                        <div className="flex gap-2">
                          <button 
                            onClick={() => setAktivesDok(entwurf)} 
                            className="flex-1 bg-orange-600 hover:bg-orange-500 px-3 py-2 rounded font-bold uppercase text-xs"
                            disabled={entwurf.entwurfId === aktivesDok.entwurfId}
                          >
                            ğŸ“ {entwurf.entwurfId === aktivesDok.entwurfId ? 'Wird bearbeitet' : 'Laden'}
                          </button>
                          <button 
                            onClick={() => {
                              if (confirm('Entwurf wirklich verwerfen? Diese Aktion kann nicht rÃ¼ckgÃ¤ngig gemacht werden.')) {
                                // Entwurf aus Liste entfernen
                                updateState(prev => ({
                                  ...prev,
                                  entwuerfe: (prev.entwuerfe || []).filter(e => e.entwurfId !== entwurf.entwurfId)
                                }));
                                // Wenn der aktive Entwurf gelÃ¶scht wird, neues leeres Dokument erstellen
                                if (entwurf.entwurfId === aktivesDok.entwurfId) {
                                  newDok();
                                }
                              }
                            }} 
                            className="bg-red-600 hover:bg-red-500 px-3 py-2 rounded font-bold uppercase text-xs"
                          >
                            ğŸ—‘ï¸
                          </button>
                        </div>
                      </div>
                    ))
                  ) : (
                    <p className="text-slate-500 text-xs italic mt-2">Keine offenen EntwÃ¼rfe vorhanden.</p>
                  )}
                </>
              ) : (
                <>
                  {/* Normale Dokumentenliste */}
                  {sortedRechnungen.length === 0 && <p className="text-slate-500 text-xs italic">Keine Belege gefunden.</p>}
                  {sortedRechnungen.map(d => (
                    <div key={d.id} className="p-3 bg-slate-800 rounded border border-slate-700 text-xs hover:bg-slate-700 flex flex-col gap-1">
                      <div className="flex justify-between items-center">
                        <div className="cursor-pointer flex-1" onClick={() => loadDok(d)}>
                          <div className={`font-bold ${d.typ === "RECHNUNG" ? "text-green-400" : d.typ === "ANGEBOT" ? "text-blue-400" : d.typ === "ABSCHLAGSRECHNUNG" ? "text-orange-400" : d.typ === "LEERES_DOKUMENT" ? "text-purple-400" : "text-yellow-400"}`}>
                            {d.typ === "LEERES_DOKUMENT" ? "LEERES DOK." : d.typ} {d.nummer} {d.muster ? "(Muster)" : ""}
                          </div>
                          <div className="text-slate-400 text-[11px]">
                            {d.datum} â€“ {d.kunde.name || "Kein Kunde"}
                          </div>
                        </div>
                      </div>
                      <div className="flex gap-2 mt-1">
                        {d.muster ? (
                          <button onClick={e => { e.stopPropagation(); removeMuster(d); }} className="bg-orange-600 hover:bg-orange-500 px-2 py-1 rounded font-bold uppercase text-xs flex-1">
                            Von Muster entfernen
                          </button>
                        ) : (
                          <button onClick={e => { e.stopPropagation(); copyAsMuster(d); }} className="bg-purple-600 hover:bg-purple-500 px-2 py-1 rounded font-bold uppercase text-xs flex-1">
                            Als Muster speichern
                          </button>
                        )}
                        <button onClick={e => { e.stopPropagation(); deleteDok(d); }} className="bg-red-600 hover:bg-red-500 px-2 py-1 rounded font-bold uppercase text-xs">
                          LÃ¶schen
                        </button>
                      </div>
                    </div>
                  ))}
                </>
              )}
            </>
          )}

          {activeTab === "neu" && (
            <div className="space-y-6">
              <div className="bg-slate-800 p-4 rounded border border-teal-900">
                <p className="font-bold text-teal-400 uppercase mb-2 text-xs">Neuer Kunde</p>
                <select value={neuKunde.anrede} onChange={e => setNeuKunde({...neuKunde, anrede: e.target.value})} className="w-full p-2 bg-slate-700 text-white rounded mb-2 text-xs">
                  <option value="Organisation">Organisation</option>
                  <option value="Herr">Herr</option>
                  <option value="Frau">Frau</option>
                </select>
                <input type="text" placeholder="Name / Firma" className="w-full p-2 text-black rounded mb-2 text-xs" value={neuKunde.name} onChange={e => setNeuKunde({...neuKunde, name: e.target.value})} />
                <input type="text" placeholder="StraÃŸe" className="w-full p-2 text-black rounded mb-2 text-xs" value={neuKunde.strasse} onChange={e => setNeuKunde({...neuKunde, strasse: e.target.value})} />
                <div className="flex gap-2">
                  <input type="text" placeholder="PLZ" className="w-1/3 p-2 text-black rounded text-xs" value={neuKunde.plz} onChange={e => setNeuKunde({...neuKunde, plz: e.target.value})} />
                  <input type="text" placeholder="Ort" className="w-2/3 p-2 text-black rounded text-xs" value={neuKunde.ort} onChange={e => setNeuKunde({...neuKunde, ort: e.target.value})} />
                </div>
                <button onClick={() => {
                  const k = { ...neuKunde, id: Date.now() };
                  saveToDB({ ...db, kunden: [k, ...db.kunden] });
                  waehleKunde(k);
                  setNeuKunde({ anrede: "Organisation", name: "", strasse: "", plz: "", ort: "" });
                }} className="mt-2 w-full bg-teal-600 py-2 rounded font-bold uppercase text-xs">
                  Kunde Speichern
                </button>
              </div>

              <div className="bg-slate-800 p-4 rounded border border-teal-900">
                <p className="font-bold text-teal-400 uppercase mb-2 text-xs">Neue Position</p>
                <input type="text" placeholder="Materialname" className="w-full p-2 text-black rounded mb-2 text-xs" value={neuMat.name} onChange={e => setNeuMat({...neuMat, name: e.target.value})} />
                <div className="flex gap-2">
                  <input type="text" placeholder="Einheit" className="w-1/2 p-2 text-black rounded text-xs" value={neuMat.einheit} onChange={e => setNeuMat({...neuMat, einheit: e.target.value})} />
                  <input type="text" placeholder="Preis â‚¬" className="w-1/2 p-2 text-black rounded text-xs" value={neuMat.preis} onChange={e => setNeuMat({...neuMat, preis: e.target.value})} />
                </div>
                <button onClick={() => {
                  const m = { Name: neuMat.name, Einheit: neuMat.einheit, Verkaufspreis: neuMat.preis.replace(',', '.'), id: Date.now() };
                  saveToDB({ ...db, material: [m, ...db.material] });
                  setNeuMat({ name: "", einheit: "Stk", preis: "0,00" });
                }} className="mt-2 w-full bg-teal-600 py-2 rounded font-bold uppercase text-xs">
                  Material Speichern
                </button>
              </div>
            </div>
          )}

          {activeTab === "einstellungen" && (
            <div className="space-y-4">
              <p className="font-bold text-teal-400 uppercase text-xs mb-2">âš™ï¸ Firmeneinstellungen</p>
              
              {/* Logo Upload */}
              <div className="bg-slate-800 p-3 rounded border border-teal-900">
                <p className="text-xs text-slate-400 mb-2">Logo</p>
                <div className="flex items-center gap-2 mb-2">
                  {firmenDaten.logo && (
                    <img src={firmenDaten.logo} alt="Logo" style={{ maxHeight: '40px', maxWidth: '100px' }} />
                  )}
                  <button onClick={() => logoInputRef.current?.click()} className="bg-teal-600 px-3 py-1 rounded text-xs">
                    {firmenDaten.logo ? 'Ã„ndern' : 'Hochladen'}
                  </button>
                  {firmenDaten.logo && (
                    <button onClick={() => saveFirmenDaten({...firmenDaten, logo: ''})} className="bg-red-600 px-2 py-1 rounded text-xs">âœ•</button>
                  )}
                  <input ref={logoInputRef} type="file" accept="image/*" className="hidden" onChange={handleLogoUpload} />
                </div>
                <p className="text-xs text-slate-400 mb-1">Position:</p>
                <div className="flex gap-2 mb-2">
                  {['links', 'mitte', 'rechts'].map(pos => (
                    <button key={pos} onClick={() => saveFirmenDaten({...firmenDaten, logoPosition: pos})} 
                      className={`px-3 py-1 rounded text-xs ${firmenDaten.logoPosition === pos ? 'bg-teal-600' : 'bg-slate-700'}`}>
                      {pos.charAt(0).toUpperCase() + pos.slice(1)}
                    </button>
                  ))}
                </div>
                <p className="text-xs text-slate-400 mb-1">GrÃ¶ÃŸe (mm):</p>
                <div className="flex gap-2">
                  <div className="flex-1">
                    <label className="text-xs text-slate-500">Breite</label>
                    <input type="number" className="w-full p-2 text-black rounded text-xs" 
                      value={firmenDaten.logoBreite || 40} 
                      onChange={e => saveFirmenDaten({...firmenDaten, logoBreite: parseInt(e.target.value) || 40})} />
                  </div>
                  <div className="flex-1">
                    <label className="text-xs text-slate-500">HÃ¶he</label>
                    <input type="number" className="w-full p-2 text-black rounded text-xs" 
                      value={firmenDaten.logoHoehe || 15} 
                      onChange={e => saveFirmenDaten({...firmenDaten, logoHoehe: parseInt(e.target.value) || 15})} />
                  </div>
                </div>
              </div>

              {/* Firmenname & Farben */}
              <div className="bg-slate-800 p-3 rounded border border-teal-900">
                <p className="text-xs text-slate-400 mb-1">Firmenname</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.firmenname} onChange={e => saveFirmenDaten({...firmenDaten, firmenname: e.target.value})} />
                <p className="text-xs text-slate-400 mb-1">PrimÃ¤rfarbe (Ãœberschriften)</p>
                <div className="flex gap-2 items-center mb-2">
                  <input type="color" value={firmenDaten.primaerFarbe} onChange={e => saveFirmenDaten({...firmenDaten, primaerFarbe: e.target.value})} className="w-10 h-8 rounded cursor-pointer" />
                  <input type="text" className="flex-1 p-2 text-black rounded text-xs" value={firmenDaten.primaerFarbe} onChange={e => saveFirmenDaten({...firmenDaten, primaerFarbe: e.target.value})} />
                </div>
                <p className="text-xs text-slate-400 mb-1">Briefkopf-Farbe (Absender)</p>
                <div className="flex gap-2 items-center mb-2">
                  <input type="color" value={firmenDaten.briefkopfFarbe || '#444444'} onChange={e => saveFirmenDaten({...firmenDaten, briefkopfFarbe: e.target.value})} className="w-10 h-8 rounded cursor-pointer" />
                  <input type="text" className="flex-1 p-2 text-black rounded text-xs" value={firmenDaten.briefkopfFarbe || '#444444'} onChange={e => saveFirmenDaten({...firmenDaten, briefkopfFarbe: e.target.value})} />
                </div>
                <p className="text-xs text-slate-400 mb-1">Briefkopf-Absender</p>
                <div className="flex gap-2">
                  <button 
                    onClick={() => saveFirmenDaten({...firmenDaten, briefkopfAbsender: 'inhaber'})}
                    className={`flex-1 py-2 rounded text-xs ${firmenDaten.briefkopfAbsender !== 'firmenname' ? 'bg-teal-600' : 'bg-slate-700'}`}
                  >Inhaber</button>
                  <button 
                    onClick={() => saveFirmenDaten({...firmenDaten, briefkopfAbsender: 'firmenname'})}
                    className={`flex-1 py-2 rounded text-xs ${firmenDaten.briefkopfAbsender === 'firmenname' ? 'bg-teal-600' : 'bg-slate-700'}`}
                  >Firmenname</button>
                </div>
              </div>

              {/* Adresse */}
              <div className="bg-slate-800 p-3 rounded border border-teal-900">
                <p className="text-xs text-slate-400 mb-1">Inhaber</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.inhaberName} onChange={e => saveFirmenDaten({...firmenDaten, inhaberName: e.target.value})} />
                <p className="text-xs text-slate-400 mb-1">StraÃŸe</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.strasse} onChange={e => saveFirmenDaten({...firmenDaten, strasse: e.target.value})} />
                <div className="flex gap-2">
                  <div className="w-1/3">
                    <p className="text-xs text-slate-400 mb-1">PLZ</p>
                    <input type="text" className="w-full p-2 text-black rounded text-xs" 
                      value={firmenDaten.plz} onChange={e => saveFirmenDaten({...firmenDaten, plz: e.target.value})} />
                  </div>
                  <div className="w-2/3">
                    <p className="text-xs text-slate-400 mb-1">Ort</p>
                    <input type="text" className="w-full p-2 text-black rounded text-xs" 
                      value={firmenDaten.ort} onChange={e => saveFirmenDaten({...firmenDaten, ort: e.target.value})} />
                  </div>
                </div>
                <p className="text-xs text-slate-400 mb-1 mt-2">Land</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs" 
                  value={firmenDaten.land} onChange={e => saveFirmenDaten({...firmenDaten, land: e.target.value})} />
              </div>

              {/* Kontakt */}
              <div className="bg-slate-800 p-3 rounded border border-teal-900">
                <p className="text-xs text-slate-400 mb-1">Telefon</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.telefon} onChange={e => saveFirmenDaten({...firmenDaten, telefon: e.target.value})} />
                <p className="text-xs text-slate-400 mb-1">E-Mail</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.email} onChange={e => saveFirmenDaten({...firmenDaten, email: e.target.value})} />
                <p className="text-xs text-slate-400 mb-1">Website</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs" 
                  value={firmenDaten.website} onChange={e => saveFirmenDaten({...firmenDaten, website: e.target.value})} />
              </div>

              {/* Steuer & Bank */}
              <div className="bg-slate-800 p-3 rounded border border-teal-900">
                <p className="text-xs text-slate-400 mb-1">Steuernummer</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.steuernummer} onChange={e => saveFirmenDaten({...firmenDaten, steuernummer: e.target.value})} />
                <p className="text-xs text-slate-400 mb-1">Bank</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.bankName} onChange={e => saveFirmenDaten({...firmenDaten, bankName: e.target.value})} />
                <p className="text-xs text-slate-400 mb-1">IBAN</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.iban} onChange={e => saveFirmenDaten({...firmenDaten, iban: e.target.value})} />
                <p className="text-xs text-slate-400 mb-1">BIC</p>
                <input type="text" className="w-full p-2 text-black rounded text-xs" 
                  value={firmenDaten.bic} onChange={e => saveFirmenDaten({...firmenDaten, bic: e.target.value})} />
              </div>

              {/* Zahlungsbedingungen */}
              <div className="bg-slate-800 p-3 rounded border border-teal-900">
                <p className="font-bold text-teal-400 uppercase text-xs mb-2">Zahlungsbedingungen</p>
                <p className="text-xs text-slate-400 mb-1">Zahlungsziel (Tage)</p>
                <input type="number" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.zahlungsziel || 10} onChange={e => saveFirmenDaten({...firmenDaten, zahlungsziel: parseInt(e.target.value) || 10})} />
                <p className="text-xs text-slate-400 mb-1">AngebotsgÃ¼ltigkeit (Tage)</p>
                <input type="number" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.angebotsgueltigkeit || 30} onChange={e => saveFirmenDaten({...firmenDaten, angebotsgueltigkeit: parseInt(e.target.value) || 30})} />
                <p className="text-xs text-slate-400 mb-1">Stundensatz (â‚¬)</p>
                <input type="number" className="w-full p-2 text-black rounded text-xs mb-2" 
                  value={firmenDaten.stundensatz || 59} onChange={e => saveFirmenDaten({...firmenDaten, stundensatz: parseInt(e.target.value) || 59})} />
                <p className="text-xs text-slate-400 mb-1">Angebots-Hinweistext <span className="text-slate-500">(verwende {'{stundensatz}'} als Platzhalter)</span></p>
                <textarea className="w-full p-2 text-black rounded text-xs" rows="2"
                  value={firmenDaten.angebotHinweis || "Unvorhergesehene Arbeiten werden mit {stundensatz},- â‚¬/Std. abgerechnet."}
                  onChange={e => saveFirmenDaten({...firmenDaten, angebotHinweis: e.target.value})} />
              </div>
              
              {/* CSV-Import */}
              <div className="bg-slate-800 p-3 rounded border border-blue-900">
                <p className="font-bold text-blue-400 uppercase text-xs mb-3">ğŸ“¥ CSV-Import</p>
                <p className="text-xs text-slate-500 mb-2">Importiert Kunden oder Artikel aus CSV-Dateien. Spalten werden automatisch erkannt.</p>
                <label className="block w-full bg-blue-700 hover:bg-blue-600 py-2 rounded font-bold uppercase text-xs text-center cursor-pointer">
                  ğŸ“„ CSV-Datei auswÃ¤hlen
                  <input 
                    type="file" 
                    accept=".csv,.txt" 
                    className="hidden" 
                    onChange={async (e) => {
                      const file = e.target.files[0];
                      if (!file) return;
                      e.target.value = '';
                      
                      const loading = showLoadingDialog('ğŸ“„ Lese CSV-Datei...');
                      
                      try {
                        const text = await file.text();
                        const { headers, rows, delimiter } = parseCSV(text);
                        
                        if (rows.length === 0) {
                          loading.close();
                          alert('Die CSV-Datei ist leer oder hat ein ungÃ¼ltiges Format.');
                          return;
                        }
                        
                        const detectedType = detectCSVType(headers);
                        loading.updateMessage(`ğŸ” Erkannt: ${detectedType === 'kunden' ? 'Kundendaten' : detectedType === 'material' ? 'Artikeldaten' : 'Unbekannt'}`);
                        
                        loading.close();
                        
                        // Benutzer fragen
                        const userChoice = prompt(
                          `ğŸ“Š CSV-Import\n\n` +
                          `Gefunden: ${rows.length} Zeilen\n` +
                          `Trennzeichen: "${delimiter}"\n` +
                          `Erkannter Typ: ${detectedType === 'kunden' ? 'Kunden' : detectedType === 'material' ? 'Artikel/Material' : 'Nicht eindeutig'}\n\n` +
                          `Spalten: ${headers.slice(0, 5).join(', ')}${headers.length > 5 ? '...' : ''}\n\n` +
                          `Als was importieren?\n` +
                          `1 = Kunden\n` +
                          `2 = Material/Artikel\n` +
                          `0 = Abbrechen`,
                          detectedType === 'kunden' ? '1' : detectedType === 'material' ? '2' : '0'
                        );
                        
                        if (!userChoice || userChoice === '0') return;
                        
                        let importedItems = [];
                        let targetField = '';
                        
                        if (userChoice === '1') {
                          importedItems = mapCSVToKunden(rows, headers);
                          targetField = 'kunden';
                        } else if (userChoice === '2') {
                          importedItems = mapCSVToMaterial(rows, headers);
                          targetField = 'material';
                        } else {
                          alert('UngÃ¼ltige Auswahl');
                          return;
                        }
                        
                        if (importedItems.length === 0) {
                          alert('Keine gÃ¼ltigen EintrÃ¤ge gefunden. PrÃ¼fen Sie das CSV-Format.');
                          return;
                        }
                        
                        // Vorschau der ersten 3 EintrÃ¤ge
                        const preview = importedItems.slice(0, 3).map(item => 
                          targetField === 'kunden' 
                            ? `â€¢ ${item.name} (${item.plz} ${item.ort})`
                            : `â€¢ ${item.name} - ${item.preis}â‚¬/${item.einheit}`
                        ).join('\n');
                        
                        if (!confirm(`${importedItems.length} ${targetField === 'kunden' ? 'Kunden' : 'Positionen'} importieren?\n\nVorschau:\n${preview}${importedItems.length > 3 ? '\n...' : ''}`)) return;
                        
                        // Import durchfÃ¼hren
                        updateState(prev => ({
                          ...prev,
                          [targetField]: [...prev[targetField], ...importedItems]
                        }));
                        
                        await forceSave();
                        alert(`âœ… ${importedItems.length} ${targetField === 'kunden' ? 'Kunden' : 'Positionen'} erfolgreich importiert!`);
                        
                      } catch (err) {
                        loading.close();
                        console.error('CSV-Import Fehler:', err);
                        alert('Fehler beim CSV-Import: ' + err.message);
                      }
                    }}
                  />
                </label>
                <p className="text-xs text-slate-600 mt-2">UnterstÃ¼tzt: Komma (,) und Semikolon (;) als Trennzeichen</p>
              </div>
              
              {/* Stammdaten Export */}
              <div className="bg-slate-800 p-3 rounded border border-blue-900">
                <p className="font-bold text-blue-400 uppercase text-xs mb-2">ğŸ“¦ Stammdaten Export</p>
                <p className="text-xs text-slate-500 mb-2">Exportiert Kunden, Positionen und Einstellungen (ohne Rechnungen/Angebote).</p>
                <button 
                  onClick={exportStammdatenFile}
                  className="w-full bg-blue-700 hover:bg-blue-600 py-2 rounded font-bold uppercase text-xs"
                >
                  ğŸ“¦ Stammdaten exportieren
                </button>
              </div>
              
              {/* Cloud-Sync Einstellungen */}
              <div className="bg-slate-800 p-3 rounded border border-purple-900">
                <p className="font-bold text-purple-400 uppercase text-xs mb-3">â˜ï¸ Cloud-Sync (Hybrid-Backup)</p>
                <p className="text-xs text-slate-500 mb-3">
                  Synchronisiert deine verschlÃ¼sselten Daten automatisch in die Cloud. Die Daten bleiben Ende-zu-Ende verschlÃ¼sselt.
                </p>
                
                {/* Status-Anzeige */}
                <div className="mb-3 p-2 rounded bg-slate-900 text-xs">
                  <div className="flex items-center gap-2">
                    <span>Status:</span>
                    {syncStatus === 'idle' && <span className="text-slate-400">â— Bereit</span>}
                    {syncStatus === 'uploading' && <span className="text-yellow-400">â—Œ Synchronisiere...</span>}
                    {syncStatus === 'success' && <span className="text-green-400">âœ“ Erfolgreich</span>}
                    {syncStatus === 'error' && <span className="text-red-400">âœ— Fehler</span>}
                  </div>
                  {lastSyncError && syncStatus === 'error' && (
                    <p className="text-red-400 text-xs mt-1">{lastSyncError}</p>
                  )}
                </div>
                
                {/* Aktivieren/Deaktivieren Toggle */}
                <div className="flex items-center gap-3 mb-3">
                  <button 
                    onClick={() => updateCloudConfig({ enabled: !cloudConfig.enabled })}
                    className={`relative w-12 h-6 rounded-full transition-colors ${cloudConfig.enabled ? 'bg-purple-600' : 'bg-slate-600'}`}
                  >
                    <div className={`absolute top-1 w-4 h-4 bg-white rounded-full transition-transform ${cloudConfig.enabled ? 'left-7' : 'left-1'}`}></div>
                  </button>
                  <span className="text-xs text-slate-300">
                    {cloudConfig.enabled ? 'Cloud-Sync aktiviert' : 'Cloud-Sync deaktiviert'}
                  </span>
                </div>
                
                {/* LizenzschlÃ¼ssel */}
                <p className="text-xs text-slate-400 mb-1">LizenzschlÃ¼ssel</p>
                <input 
                  type="password" 
                  placeholder="Dein LizenzschlÃ¼ssel..." 
                  className="w-full p-2 text-black rounded text-xs mb-3" 
                  value={cloudConfig.licenseKey || ''} 
                  onChange={e => updateCloudConfig({ licenseKey: e.target.value })}
                />
                
                {/* Manueller Sync-Button */}
                <button 
                  onClick={triggerCloudSync}
                  disabled={!cloudConfig.enabled || !cloudConfig.licenseKey || !cloudConfig.workerUrl || syncStatus === 'uploading'}
                  className={`w-full py-2 rounded font-bold uppercase text-xs ${
                    cloudConfig.enabled && cloudConfig.licenseKey && cloudConfig.workerUrl && syncStatus !== 'uploading'
                      ? 'bg-purple-600 hover:bg-purple-500' 
                      : 'bg-slate-600 cursor-not-allowed'
                  }`}
                >
                  {syncStatus === 'uploading' ? 'â—Œ Synchronisiere...' : 'â˜ï¸ Jetzt synchronisieren'}
                </button>
                
                {/* Cloud-Restore Button */}
                <button 
                  onClick={restoreFromCloud}
                  disabled={!cloudConfig.enabled || !cloudConfig.licenseKey || !cloudConfig.workerUrl || syncStatus === 'uploading' || syncStatus === 'downloading'}
                  className={`w-full py-2 mt-2 rounded font-bold uppercase text-xs ${
                    cloudConfig.enabled && cloudConfig.licenseKey && cloudConfig.workerUrl && syncStatus !== 'uploading' && syncStatus !== 'downloading'
                      ? 'bg-indigo-600 hover:bg-indigo-500' 
                      : 'bg-slate-600 cursor-not-allowed'
                  }`}
                >
                  {syncStatus === 'downloading' ? 'â—Œ Lade...' : 'ğŸ“¥ Aus Cloud wiederherstellen'}
                </button>
                
                <p className="text-xs text-slate-600 mt-2">
                  ğŸ” Daten werden lokal verschlÃ¼sselt, bevor sie hochgeladen werden.
                </p>
              </div>
            </div>
          )}
        </div>

        {/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * SIDEBAR FOOTER - Kompakte Version (Backup-Buttons bleiben hier)
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */}
        <div className="pt-4 border-t border-slate-700 space-y-2 text-xs">
          <div className="grid grid-cols-2 gap-2">
            <button onClick={exportFullBackup} className="bg-indigo-700 py-2 rounded font-bold uppercase hover:bg-indigo-600 text-[10px]">
              ğŸ” Backup
            </button>
            <label className="bg-indigo-600 py-2 rounded text-center cursor-pointer hover:bg-indigo-500 font-bold uppercase block text-[10px]">
              ğŸ”“ Import
              <input type="file" className="hidden" accept=".json,.txt,.enc" onChange={(e) => {
                const file = e.target.files[0];
                if (file) {
                  importBackupFile(file);
                  e.target.value = '';
                }
              }} />
            </label>
          </div>
          
          {/* .dat Archiv Ã¶ffnen */}
          <label className="block w-full bg-slate-700 hover:bg-slate-600 py-2 rounded font-bold uppercase text-center cursor-pointer border border-dashed border-slate-500 text-[10px]">
            ğŸ”“ .dat Archiv Ã¶ffnen
            <input 
              type="file" 
              className="hidden" 
              accept=".dat"
              onChange={async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                e.target.value = '';
                
                const password = prompt('ğŸ”‘ Archiv-Passwort eingeben:');
                if (!password) return;
                
                const loading = showLoadingDialog('ğŸ”“ EntschlÃ¼ssele...');
                
                try {
                  const arrayBuffer = await file.arrayBuffer();
                  const bytes = new Uint8Array(arrayBuffer);
                  
                  const salt = bytes.slice(0, 16);
                  const iv = bytes.slice(16, 28);
                  const encryptedData = bytes.slice(28);
                  
                  const keyMaterial = await crypto.subtle.importKey(
                    'raw', new TextEncoder().encode(password), 'PBKDF2', false, ['deriveBits', 'deriveKey']
                  );
                  
                  const key = await crypto.subtle.deriveKey(
                    { name: 'PBKDF2', salt, iterations: 310000, hash: 'SHA-256' },
                    keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['decrypt']
                  );
                  
                  const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv, tagLength: 128 }, key, encryptedData
                  );
                  
                  const decryptedBytes = new Uint8Array(decrypted);
                  const view = new DataView(decrypted);
                  
                  const pdfLength = view.getUint32(0, true);
                  const pdfData = decryptedBytes.slice(8, 8 + pdfLength);
                  const pdfBlob = new Blob([pdfData], { type: 'application/pdf' });
                  
                  loading.close();
                  
                  const pdfUrl = URL.createObjectURL(pdfBlob);
                  window.open(pdfUrl, '_blank');
                  setTimeout(() => URL.revokeObjectURL(pdfUrl), 60000);
                  
                } catch (err) {
                  loading.close();
                  if (err.name === 'OperationError') {
                    alert('âŒ Falsches Passwort!');
                  } else {
                    alert('Fehler: ' + err.message);
                  }
                }
              }}
            />
          </label>
        </div>
      </div>

      {/* Vorschau */}
      <div className="main-content flex-1 pt-16 md:pt-0 pb-20 md:pb-6 p-4 md:p-6 lg:p-12 bg-slate-50 overflow-y-auto overflow-x-auto w-full">
        <div
          id="rechnung-druck"
          className="md:mx-auto"
          style={{
            width: '210mm',
            minWidth: '210mm',
            minHeight: '297mm',
            padding: '25mm 20mm 45mm 25mm',
            background: 'white',
            fontFamily: 'Arial, Helvetica, sans-serif',
            fontSize: '11pt',
            lineHeight: '1.45',
            color: '#111',
            boxSizing: 'border-box',
            position: 'relative',
            overflow: 'hidden'
          }}
        >
          <div className="page-content">
            {/* GroÃŸer Header mit Logo */}
            <div className="page-header">
              {/* Logo wenn vorhanden */}
              {firmenDaten.logo && (
                <div style={{ 
                  display: 'flex',
                  justifyContent: firmenDaten.logoPosition === 'mitte' ? 'center' : firmenDaten.logoPosition === 'rechts' ? 'flex-end' : 'flex-start',
                  marginBottom: '4mm'
                }}>
                  <img src={firmenDaten.logo} alt="Logo" style={{ 
                    width: `${firmenDaten.logoBreite || 40}mm`, 
                    height: `${firmenDaten.logoHoehe || 15}mm`,
                    objectFit: 'contain'
                  }} />
                </div>
              )}
              {/* Firmenname nur anzeigen wenn kein Logo */}
              {!firmenDaten.logo && (
                <div style={{ fontSize: '28pt', fontWeight: 'bold', color: firmenDaten.primaerFarbe, marginBottom: '14mm', textAlign: 'center', letterSpacing: '1px' }}>
                  {firmenDaten.firmenname.toUpperCase()}
                </div>
              )}

              {/* Absenderzeile klein */}
              <div style={{ fontSize: '9pt', color: firmenDaten.briefkopfFarbe || '#444', marginBottom: '14mm', borderBottom: '1px solid #ccc', paddingBottom: '2mm', textAlign: 'left' }}>
                {firmenDaten.briefkopfAbsender === "firmenname" ? firmenDaten.firmenname : firmenDaten.inhaberName} Â· {firmenDaten.strasse} Â· {firmenDaten.plz} {firmenDaten.ort}
              </div>
            </div>

            {/* Anschrift â€“ zeilenweise (DIN-konform) */}
            <div style={{ marginBottom: '18mm', width: '90mm', lineHeight: '1.6' }}>
              {aktivesDok.kunde.name && <div style={{ fontWeight: 'bold' }}>{aktivesDok.kunde.name}</div>}
              {aktivesDok.kunde.strasse && <div>{aktivesDok.kunde.strasse}</div>}
              {(aktivesDok.kunde.plz || aktivesDok.kunde.ort) && <div>{[aktivesDok.kunde.plz, aktivesDok.kunde.ort].filter(Boolean).join(' ')}</div>}
            </div>

            {/* Rechnungskopf */}
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', marginBottom: '12mm', paddingBottom: '4mm' }}>
              <div>
                <select 
                  className="no-print"
                  value={aktivesDok.typ} 
                  onChange={e => setAktivesDok({...aktivesDok, typ: e.target.value})} 
                  style={{ fontSize: '16pt', fontWeight: 'bold', color: firmenDaten.primaerFarbe, border: `2px solid ${firmenDaten.primaerFarbe}`, padding: '4px 8px', borderRadius: '4px', marginBottom: '4px', cursor: 'pointer' }}
                >
                  <option value="RECHNUNG">RECHNUNG</option>
                  <option value="ABSCHLAGSRECHNUNG">ABSCHLAGSRECHNUNG</option>
                  <option value="ANGEBOT">ANGEBOT</option>
                  <option value="LEERES_DOKUMENT">LEERES DOKUMENT</option>
                </select>
                {aktivesDok.typ === "LEERES_DOKUMENT" ? (
                  <input 
                    type="text" 
                    style={{ fontSize: '22pt', fontWeight: 'bold', color: firmenDaten.primaerFarbe, margin: 0, border: `1px dashed ${firmenDaten.primaerFarbe}`, padding: '2px 8px', borderRadius: '4px', width: '100%' }}
                    value={aktivesDok.betreff || ""}
                    onChange={e => setAktivesDok({...aktivesDok, betreff: e.target.value})}
                    placeholder="Betreff eingeben..."
                  />
                ) : (
                  <h1 style={{ fontSize: '22pt', fontWeight: 'bold', color: firmenDaten.primaerFarbe, margin: 0 }}>{aktivesDok.typ === "LEERES_DOKUMENT" ? "LEERES DOKUMENT" : aktivesDok.typ}</h1>
                )}
              </div>
              <div style={{ textAlign: 'right', fontSize: '10pt' }}>
                <div>{aktivesDok.typ === "ANGEBOT" ? "Angebots" : aktivesDok.typ === "ABSCHLAGSRECHNUNG" ? "Abschlagsrechnungs" : aktivesDok.typ === "LEERES_DOKUMENT" ? "Dok." : "Rechnungs"}-Nr.: <input style={{ border: 'none', borderBottom: '1px dashed #666', outline: 'none', width: '110px', textAlign: 'right' }} value={aktivesDok.nummer} onChange={e => setAktivesDok({...aktivesDok, nummer: e.target.value})} /></div>
                <div>Datum: <input style={{ border: 'none', borderBottom: '1px dashed #666', outline: 'none', width: '90px', textAlign: 'right' }} value={aktivesDok.datum} onChange={e => setAktivesDok({...aktivesDok, datum: e.target.value})} /></div>
                {aktivesDok.typ !== "ANGEBOT" && aktivesDok.typ !== "LEERES_DOKUMENT" && (
                  <div style={{ fontSize: '10pt' }}>Leistungszeitraum: <input style={{ border: 'none', borderBottom: '1px dashed #666', outline: 'none', width: '70px', textAlign: 'right' }} placeholder="von" value={aktivesDok.leistungszeitraum?.von || ""} onChange={e => setAktivesDok({...aktivesDok, leistungszeitraum: {...(aktivesDok.leistungszeitraum || {}), von: e.target.value}})} /> - <input style={{ border: 'none', borderBottom: '1px dashed #666', outline: 'none', width: '70px', textAlign: 'right' }} placeholder="bis" value={aktivesDok.leistungszeitraum?.bis || ""} onChange={e => setAktivesDok({...aktivesDok, leistungszeitraum: {...(aktivesDok.leistungszeitraum || {}), bis: e.target.value}})} /></div>
                )}
              </div>
            </div>

            {/* Arbeitsort - editierbar (nicht bei Leeres Dokument) */}
            {aktivesDok.typ !== "LEERES_DOKUMENT" && (
            <div style={{ marginBottom: '8mm', fontSize: '10pt', color: '#444' }}>
              <input 
                type="text" 
                style={{ width: '100%', border: '1px solid #ccc', padding: '4px 6px', fontSize: '10pt', borderRadius: '3px', outline: 'none' }}
                value={aktivesDok.arbeitsort || (aktivesDok.typ === "ANGEBOT" 
                  ? (aktivesDok.kunde.strasse && aktivesDok.kunde.ort ? `FÃ¼r die Arbeiten in der ${aktivesDok.kunde.strasse} in ${aktivesDok.kunde.ort}.` : aktivesDok.kunde.strasse ? `FÃ¼r die Arbeiten in der ${aktivesDok.kunde.strasse}.` : 'FÃ¼r die Arbeiten in der StraÃŸe des Kunden.')
                  : (aktivesDok.kunde.strasse && aktivesDok.kunde.ort ? `FÃ¼r die ausgefÃ¼hrten Arbeiten in der ${aktivesDok.kunde.strasse} in ${aktivesDok.kunde.ort}.` : aktivesDok.kunde.strasse ? `FÃ¼r die ausgefÃ¼hrten Arbeiten in der ${aktivesDok.kunde.strasse}.` : 'FÃ¼r die ausgefÃ¼hrten Arbeiten in der StraÃŸe des Kunden.'))}
                onChange={e => setAktivesDok({...aktivesDok, arbeitsort: e.target.value})}
                placeholder="Ort der Arbeiten"
              />
            </div>
            )}

            {/* Freitext und Signatur fÃ¼r Leeres Dokument */}
            {aktivesDok.typ === "LEERES_DOKUMENT" && (
              <>
                <div style={{ marginBottom: '8mm' }}>
                  <textarea
                    style={{ 
                      width: '100%', 
                      minHeight: '300px', 
                      border: '1px solid #ccc', 
                      padding: '8px 12px', 
                      fontSize: '11pt', 
                      borderRadius: '4px', 
                      outline: 'none',
                      lineHeight: '1.6',
                      fontFamily: 'inherit',
                      resize: 'vertical'
                    }}
                    value={aktivesDok.freitext || ""}
                    onChange={e => setAktivesDok({...aktivesDok, freitext: e.target.value})}
                    placeholder="Geben Sie hier Ihren Text ein..."
                  />
                </div>
                
                {/* Signatur-Optionen */}
                <div className="no-print" style={{ marginBottom: '8mm', padding: '12px', backgroundColor: '#f8f9fa', borderRadius: '4px', border: '1px solid #ddd' }}>
                  <div style={{ fontWeight: 'bold', marginBottom: '8px', fontSize: '10pt', color: '#333' }}>Signaturfelder (optional)</div>
                  <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: '10pt', marginBottom: '6px' }}>
                    <input 
                      type="checkbox" 
                      checked={aktivesDok.signaturKunde || false}
                      onChange={e => setAktivesDok({...aktivesDok, signaturKunde: e.target.checked})}
                      style={{ marginRight: '8px', width: '18px', height: '18px' }}
                    />
                    <span style={{ color: '#333' }}>
                      <strong>Unterschrift Kunde</strong> â€“ Feld fÃ¼r Kundenunterschrift
                    </span>
                  </label>
                  <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: '10pt' }}>
                    <input 
                      type="checkbox" 
                      checked={aktivesDok.signaturAbsender || false}
                      onChange={e => setAktivesDok({...aktivesDok, signaturAbsender: e.target.checked})}
                      style={{ marginRight: '8px', width: '18px', height: '18px' }}
                    />
                    <span style={{ color: '#333' }}>
                      <strong>{firmenDaten.inhaberName}</strong> â€“ Ihre Unterschrift
                    </span>
                  </label>
                </div>
                
                {/* Signaturfelder-Vorschau */}
                {(aktivesDok.signaturKunde || aktivesDok.signaturAbsender) && (
                  <div style={{ marginTop: '10mm', marginBottom: '8mm', display: 'flex', justifyContent: 'flex-start', gap: '20mm' }}>
                    {aktivesDok.signaturAbsender && (
                      <div style={{ flex: '0 0 45%' }}>
                        <div style={{ fontSize: '9pt', color: '#666', marginBottom: '2mm' }}>{firmenDaten.inhaberName}</div>
                        <canvas
                          ref={signaturCanvasRef}
                          width={200}
                          height={80}
                          style={{ 
                            border: '1px solid #ccc', 
                            borderRadius: '4px', 
                            backgroundColor: '#fff',
                            touchAction: 'none',
                            cursor: 'crosshair'
                          }}
                          onMouseDown={startDrawing}
                          onMouseMove={draw}
                          onMouseUp={stopDrawing}
                          onMouseLeave={stopDrawing}
                          onTouchStart={startDrawing}
                          onTouchMove={draw}
                          onTouchEnd={stopDrawing}
                        />
                        <div style={{ marginTop: '2mm', display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' }}>
                          <button 
                            type="button" 
                            onClick={clearSignaturCanvas}
                            style={{ fontSize: '8pt', padding: '2px 8px', cursor: 'pointer', backgroundColor: '#f0f0f0', border: '1px solid #ccc', borderRadius: '3px' }}
                          >
                            LÃ¶schen
                          </button>
                          <span style={{ fontSize: '8pt', color: '#666' }}>Ort:</span>
                          <input 
                            type="text" 
                            value={aktivesDok.signaturAbsenderOrt || ""}
                            onChange={e => setAktivesDok({...aktivesDok, signaturAbsenderOrt: e.target.value})}
                            placeholder="Ort"
                            style={{ 
                              fontSize: '8pt', 
                              padding: '2px 6px', 
                              border: '1px solid #ccc', 
                              borderRadius: '3px',
                              width: '80px'
                            }}
                          />
                          <span style={{ fontSize: '8pt', color: '#666' }}>Datum:</span>
                          <input 
                            type="text" 
                            value={aktivesDok.signaturAbsenderDatum || ""}
                            onChange={e => setAktivesDok({...aktivesDok, signaturAbsenderDatum: e.target.value})}
                            placeholder="TT.MM.JJJJ"
                            style={{ 
                              fontSize: '8pt', 
                              padding: '2px 6px', 
                              border: '1px solid #ccc', 
                              borderRadius: '3px',
                              width: '80px'
                            }}
                          />
                        </div>
                      </div>
                    )}
                    {aktivesDok.signaturKunde && (
                      <div style={{ flex: '0 0 45%' }}>
                        <div style={{ borderTop: '1px solid #333', paddingTop: '2mm', marginTop: '62px' }}>
                          <div style={{ fontSize: '9pt', color: '#666' }}>Unterschrift Kunde</div>
                          <div style={{ fontSize: '8pt', color: '#999', marginTop: '1mm' }}>Ort, Datum: ________________</div>
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </>
            )}

            {/* Tabelle (nicht bei Leeres Dokument) */}
            {aktivesDok.typ !== "LEERES_DOKUMENT" && (
            <table style={{ width: '100%', borderCollapse: 'collapse', marginBottom: '12mm', fontSize: '10pt' }}>
              <thead>
                <tr style={{ borderBottom: '2px solid #006666', textAlign: 'left' }}>
                  <th className="no-print" style={{ padding: '3mm 0', width: '30px' }}>Ãœ</th>
                  {aktivesDok.typ === "ANGEBOT" && <th className="no-print" style={{ padding: '3mm 0', width: '30px' }}>Opt.</th>}
                  <th style={{ padding: '3mm 0', width: '15mm' }}>Pos.</th>
                  <th style={{ padding: '3mm 0' }}>Beschreibung</th>
                  <th style={{ padding: '3mm 0', textAlign: 'right', width: '20mm' }}>Menge</th>
                  <th style={{ padding: '3mm 0', textAlign: 'right', width: '18mm' }}>Einheit</th>
                  <th style={{ padding: '3mm 0', textAlign: 'right', width: '28mm' }}>Einzelpreis â‚¬</th>
                  <th style={{ padding: '3mm 0', textAlign: 'right', width: '28mm' }}>Gesamt â‚¬</th>
                  <th className="no-print" style={{ width: '20px' }}></th>
                </tr>
              </thead>
              <tbody>
                {aktivesDok.positionen.map((p, i) => {
                  // Berechne die tatsÃ¤chliche Positionsnummer (ohne Ãœberschriften und optionale)
                  const posNummer = aktivesDok.positionen.slice(0, i).filter(pos => !pos.isUeberschrift && !pos.isOptional).length + (p.isUeberschrift || p.isOptional ? 0 : 1);
                  const posLabel = p.isOptional ? "Opt." : (p.isUeberschrift ? '' : posNummer);
                  const gesamtBetrag = (parseVal(p.menge) * parseVal(p.preis)).toFixed(2) + ' â‚¬';
                  const gesamtAnzeige = p.isOptional ? `(${gesamtBetrag})` : gesamtBetrag;
                  return (
                  <tr key={p.id} style={{ borderBottom: '1px solid #eee' }}>
                    <td className="no-print" style={{ padding: '3mm 0', textAlign: 'center' }}>
                      <input 
                        type="checkbox" 
                        checked={p.isUeberschrift || false}
                        onChange={e => {
                          const n = [...aktivesDok.positionen];
                          n[i].isUeberschrift = e.target.checked;
                          if (e.target.checked) n[i].isOptional = false; // Ãœberschrift kann nicht optional sein
                          setAktivesDok({...aktivesDok, positionen: n});
                        }}
                        title="Als Ãœberschrift formatieren"
                      />
                    </td>
                    {aktivesDok.typ === "ANGEBOT" && (
                      <td className="no-print" style={{ padding: '3mm 0', textAlign: 'center' }}>
                        <input 
                          type="checkbox" 
                          checked={p.isOptional || false}
                          disabled={p.isUeberschrift}
                          onChange={e => {
                            const n = [...aktivesDok.positionen];
                            n[i].isOptional = e.target.checked;
                            setAktivesDok({...aktivesDok, positionen: n});
                          }}
                          title="Als optionale Position markieren"
                        />
                      </td>
                    )}
                    <td style={{ padding: '3mm 0' }}>{posLabel}</td>
                    <td style={{ padding: '3mm 2mm 3mm 0' }}>
                      <textarea 
                        style={{ width: '100%', border: 'none', outline: 'none', resize: 'vertical', background: 'transparent', minHeight: '40px', fontWeight: p.isUeberschrift ? 'bold' : 'normal' }} 
                        rows={Math.max(2, Math.ceil(p.name.length / 50))} 
                        value={p.name} 
                        onChange={e => {
                          const n = [...aktivesDok.positionen];
                          n[i].name = e.target.value;
                          setAktivesDok({...aktivesDok, positionen: n});
                        }} 
                      />
                    </td>
                    <td style={{ padding: '3mm 0', textAlign: 'right' }}>
                      {!p.isUeberschrift && (
                        <input style={{ width: '100%', textAlign: 'right', border: 'none', outline: 'none', background: 'transparent' }} value={p.menge} onChange={e => {
                          const n = [...aktivesDok.positionen];
                          n[i].menge = e.target.value;
                          setAktivesDok({...aktivesDok, positionen: n});
                        }} />
                      )}
                    </td>
                    <td style={{ padding: '3mm 0', textAlign: 'right' }}>
                      {!p.isUeberschrift && (
                        <input style={{ width: '100%', textAlign: 'right', border: 'none', outline: 'none', background: 'transparent' }} value={p.einheit} onChange={e => {
                          const n = [...aktivesDok.positionen];
                          n[i].einheit = e.target.value;
                          setAktivesDok({...aktivesDok, positionen: n});
                        }} />
                      )}
                    </td>
                    <td style={{ padding: '3mm 0', textAlign: 'right' }}>
                      {!p.isUeberschrift && (
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end', gap: '2px' }}>
                          <input style={{ width: '90%', textAlign: 'right', border: 'none', outline: 'none', background: 'transparent' }} value={p.preis} onChange={e => {
                            const n = [...aktivesDok.positionen];
                            n[i].preis = e.target.value;
                            setAktivesDok({...aktivesDok, positionen: n});
                          }} />
                          <span>â‚¬</span>
                        </div>
                      )}
                    </td>
                    <td style={{ padding: '3mm 0', textAlign: 'right', fontWeight: 'bold' }}>
                      {!p.isUeberschrift && gesamtAnzeige}
                    </td>
                    <td className="no-print" style={{ padding: '3mm 0' }}>
                      <div className="flex gap-1 justify-end" style={{ opacity: 0.3 }} onMouseEnter={e => e.currentTarget.style.opacity = 1} onMouseLeave={e => e.currentTarget.style.opacity = 0.3}>
                        <button onClick={() => {
                          if (i > 0) {
                            const n = [...aktivesDok.positionen];
                            [n[i-1], n[i]] = [n[i], n[i-1]];
                            setAktivesDok({...aktivesDok, positionen: n});
                          }
                        }} className="text-teal-600" style={{ fontSize: '18px', fontWeight: 'bold', lineHeight: '1', padding: '2px 4px', cursor: 'pointer' }}>â†‘</button>
                        <button onClick={() => {
                          if (i < aktivesDok.positionen.length - 1) {
                            const n = [...aktivesDok.positionen];
                            [n[i+1], n[i]] = [n[i], n[i+1]];
                            setAktivesDok({...aktivesDok, positionen: n});
                          }
                        }} className="text-teal-600" style={{ fontSize: '18px', fontWeight: 'bold', lineHeight: '1', padding: '2px 4px', cursor: 'pointer' }}>â†“</button>
                        <button onClick={() => {
                          const n = aktivesDok.positionen.filter((_, idx) => idx !== i);
                          setAktivesDok({...aktivesDok, positionen: n});
                        }} className="text-red-600" style={{ fontSize: '20px', fontWeight: 'bold', lineHeight: '1', padding: '2px 4px', cursor: 'pointer' }}>Ã—</button>
                      </div>
                    </td>
                  </tr>
                  );
                })}
              </tbody>
            </table>
            )}

            {/* Summen (nicht bei Leeres Dokument) */}
            {aktivesDok.typ !== "LEERES_DOKUMENT" && (
            <div style={{ marginLeft: 'auto', width: '90mm', fontSize: '10pt' }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', padding: '2mm 0', borderTop: '1px solid #006666' }}>
                <span>Nettobetrag</span><span>{(netto - abschlagBetrag).toFixed(2)} â‚¬</span>
              </div>
              {rabattBetrag > 0 && (
                <>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1mm 0' }}>
                    <input 
                      type="text" 
                      style={{ width: '180px', padding: '2px 6px', fontSize: '10pt', border: '1px solid #999', borderRadius: '3px', color: '#006666' }}
                      value={aktivesDok.rabattBeschreibung || "Nachlass"}
                      onChange={e => setAktivesDok({...aktivesDok, rabattBeschreibung: e.target.value})}
                      placeholder="z.B. Nachlass fÃ¼r Barzahlung"
                    />
                    <span style={{ marginLeft: '4px' }}>:</span>
                    <input 
                      type="text" 
                      style={{ width: '120px', padding: '2px 6px', fontSize: '10pt', border: '1px solid #999', borderRadius: '3px', textAlign: 'right' }}
                      value={aktivesDok.rabatt || "0"}
                      onChange={e => setAktivesDok({...aktivesDok, rabatt: e.target.value})}
                      placeholder="0,00"
                    />
                    <span style={{ color: '#006666', marginLeft: '4px' }}>â‚¬</span>
                  </div>
                  <div style={{ display: 'flex', justifyContent: 'space-between', padding: '2mm 0', borderTop: '1px solid #ccc', fontWeight: 'bold' }}>
                    <span>Zwischensumme</span><span>{nettoNachRabatt.toFixed(2)} â‚¬</span>
                  </div>
                </>
              )}
              {rabattBetrag === 0 && (
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1mm 0' }}>
                  <input 
                    type="text" 
                    style={{ width: '180px', padding: '2px 6px', fontSize: '10pt', border: '1px solid #999', borderRadius: '3px', color: '#006666' }}
                    value={aktivesDok.rabattBeschreibung || "Nachlass"}
                    onChange={e => setAktivesDok({...aktivesDok, rabattBeschreibung: e.target.value})}
                    placeholder="z.B. Nachlass fÃ¼r Barzahlung"
                  />
                  <span style={{ marginLeft: '4px' }}>:</span>
                  <input 
                    type="text" 
                    style={{ width: '120px', padding: '2px 6px', fontSize: '10pt', border: '1px solid #999', borderRadius: '3px', textAlign: 'right' }}
                    value={aktivesDok.rabatt || "0"}
                    onChange={e => setAktivesDok({...aktivesDok, rabatt: e.target.value})}
                    placeholder="0,00"
                  />
                  <span style={{ color: '#006666', marginLeft: '4px' }}>â‚¬</span>
                </div>
              )}
              <div style={{ display: 'flex', justifyContent: 'space-between', padding: '1mm 0' }}>
                <span>MwSt. 19 %</span><span>{mwst.toFixed(2)} â‚¬</span>
              </div>
              <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12pt', fontWeight: 'bold', padding: '4mm 0 0 0', borderTop: '2px solid #006666' }}>
                <span>{aktivesDok.typ === "ANGEBOT" ? "Angebotssumme" : aktivesDok.typ === "ABSCHLAGSRECHNUNG" ? "Abschlagsrechnungsbetrag" : "Rechnungsbetrag"}</span><span>{brutto.toFixed(2)} â‚¬</span>
              </div>
              {aktivesDok.typ === "RECHNUNG" && (
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '3mm 0 0 0' }}>
                  <span style={{ fontSize: '10pt', color: '#006666' }}>Abzgl. Abschlagsrechnung(en):</span>
                  <input 
                    type="text" 
                    style={{ width: '120px', padding: '2px 6px', fontSize: '10pt', border: '1px solid #999', borderRadius: '3px', textAlign: 'right' }}
                    value={aktivesDok.abschlagsrechnungBetrag || "0"}
                    onChange={e => setAktivesDok({...aktivesDok, abschlagsrechnungBetrag: e.target.value})}
                    placeholder="0,00"
                  />
                  <span style={{ fontSize: '10pt', color: '#006666', marginLeft: '4px' }}>â‚¬</span>
                </div>
              )}
              {aktivesDok.typ === "RECHNUNG" && abschlagsrechnungBetrag > 0 && (
                <>
                  <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '13pt', fontWeight: 'bold', padding: '3mm 0 0 0', borderTop: '1px dashed #006666' }}>
                    <span>Restbetrag</span><span>{restbetragNachAbschlag.toFixed(2)} â‚¬</span>
                  </div>
                </>
              )}
              {abschlagProzent > 0 && (
                <>
                  <div style={{ display: 'flex', justifyContent: 'space-between', padding: '3mm 0 0 0', color: '#006666' }}>
                    <span>Abschlag {abschlagProzent} %</span><span>-{abschlagBetrag.toFixed(2)} â‚¬</span>
                  </div>
                  <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '13pt', fontWeight: 'bold', padding: '2mm 0', borderTop: '1px dashed #006666' }}>
                    <span>Restbetrag</span><span>{restBrutto.toFixed(2)} â‚¬</span>
                  </div>
                </>
              )}
            </div>
            )}
          
            {/* Zahlungsbedingungen/FuÃŸtext (nicht bei Leeres Dokument) */}
            {aktivesDok.typ !== "LEERES_DOKUMENT" && (
            <div style={{ marginTop: '6mm', marginBottom: '6mm', fontSize: '10pt', color: '#444' }}>
              <br/>
              {aktivesDok.typ === "ANGEBOT" ? (
                <>
                  {(firmenDaten.angebotHinweis || "Unvorhergesehene Arbeiten werden mit {stundensatz},- â‚¬/Std. abgerechnet.").replace('{stundensatz}', firmenDaten.stundensatz || 59)}<br/>
                  <br/>
                  Dieses Angebot ist {firmenDaten.angebotsgueltigkeit || 30} Tage ab Ausstellungsdatum gÃ¼ltig.<br/>
                  <br/>
                  Wir freuen uns auf Ihre Auftragserteilung und stehen fÃ¼r RÃ¼ckfragen gerne zur VerfÃ¼gung.<br/>
                </>
              ) : (
                <>
                  Zahlungsbedingungen: Zahlung innerhalb von {firmenDaten.zahlungsziel || 10} Tagen ab Rechnungseingang ohne AbzÃ¼ge.<br/>
                  <br/>
                  {/* Optionales Eingabefeld fÃ¼r zusÃ¤tzlichen Hinweis */}
                  <div className="no-print" style={{ marginBottom: '3mm' }}>
                    <textarea
                      style={{ 
                        width: '100%', 
                        padding: '6px 8px', 
                        fontSize: '10pt', 
                        border: '1px dashed #999', 
                        borderRadius: '4px',
                        backgroundColor: '#f9f9f9',
                        color: '#444',
                        resize: 'vertical',
                        minHeight: '40px'
                      }}
                      value={aktivesDok.rechnungshinweis || ""}
                      onChange={e => setAktivesDok({...aktivesDok, rechnungshinweis: e.target.value})}
                      placeholder="ZusÃ¤tzlicher Hinweis (optional) - z.B. Skonto-Regelung, Lieferhinweise..."
                    />
                  </div>
                  {aktivesDok.rechnungshinweis && (
                    <span className="print-only" style={{ whiteSpace: 'pre-wrap' }}>{aktivesDok.rechnungshinweis}<br/><br/></span>
                  )}
                  Bitte Ã¼berweisen Sie den Rechnungsbetrag unter Angabe der Rechnungsnummer auf das unten angegebene Konto.<br/>
                </>
              )}
              <br/>
              Mit freundlichen GrÃ¼ÃŸen<br/>
              {firmenDaten.inhaberName}
            </div>
            )}

          </div>

          {/* Fixierte FuÃŸzeile â€“ erscheint auf jeder Seite im Druck */}
          <div className="page-footer">
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr 1fr', gap: '8mm', fontSize: '8.5pt' }}>
              <div style={{ textAlign: 'left' }}>
                {firmenDaten.firmenname}<br/>
                {firmenDaten.strasse}<br/>
                {firmenDaten.plz} {firmenDaten.ort}<br/>
                {firmenDaten.land}
              </div>
              <div style={{ textAlign: 'left' }}>
                Tel. {firmenDaten.telefon}<br/>
                E-Mail: {firmenDaten.email}<br/>
                Web: {firmenDaten.website}
              </div>
              <div style={{ textAlign: 'left' }}>
                Steuer-Nr. {firmenDaten.steuernummer}<br/>
                Inhaber: {firmenDaten.inhaberName}
              </div>
              <div style={{ textAlign: 'left' }}>
                Bank: {firmenDaten.bankName}<br/>
                IBAN: {firmenDaten.iban}<br/>
                BIC: {firmenDaten.bic}
              </div>
            </div>
          </div>
        </div>

        <div className="mt-8 flex justify-center no-print">
          <button
            onClick={createPDF}
            className="bg-emerald-700 text-white px-10 py-4 rounded font-bold uppercase shadow-lg hover:bg-emerald-800"
          >
            ğŸ“„ PDF ERSTELLEN U. SPEICHERN
          </button>
        </div>

        {/* Privacy Footer */}
        <div className="privacy-footer mt-8 no-print">
          {/* Speicher-Warnung bei >90% */}
          {speicherInfo.istKritisch && (
            <div style={{
              background: 'linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%)',
              border: '2px solid #ef4444',
              borderRadius: '12px',
              padding: '16px',
              marginBottom: '16px',
              textAlign: 'center'
            }}>
              <div style={{ fontSize: '24px', marginBottom: '8px' }}>âš ï¸</div>
              <strong style={{ color: '#fca5a5', fontSize: '14px' }}>Speicher fast voll ({speicherInfo.prozent}%)</strong>
              <p style={{ color: '#fecaca', fontSize: '12px', margin: '8px 0 0 0' }}>
                Bitte Stammdaten exportieren und mit einem frischen Vault neu starten.
              </p>
            </div>
          )}
          
          {/* Speicher-Ãœbersicht */}
          <div style={{
            background: 'rgba(30, 41, 59, 0.8)',
            borderRadius: '10px',
            padding: '12px 16px',
            marginBottom: '16px',
            border: '1px solid rgba(100, 116, 139, 0.3)'
          }}>
            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '8px' }}>
              <span style={{ color: '#94a3b8', fontSize: '12px', fontWeight: '600' }}>
                ğŸ’¾ Vault-Speicher
              </span>
              <span style={{ 
                color: speicherInfo.istKritisch ? '#ef4444' : speicherInfo.istWarnung ? '#f59e0b' : '#22c55e', 
                fontSize: '12px', 
                fontWeight: '700' 
              }}>
                {speicherInfo.prozent}% belegt ({speicherInfo.belegtKB} KB / {Math.round(speicherInfo.maxDataSize/1024)} KB)
              </span>
            </div>
            <div style={{
              background: '#1e293b',
              borderRadius: '6px',
              height: '8px',
              overflow: 'hidden'
            }}>
              <div style={{
                width: `${Math.min(100, speicherInfo.prozent)}%`,
                height: '100%',
                background: speicherInfo.istKritisch 
                  ? 'linear-gradient(90deg, #dc2626, #ef4444)' 
                  : speicherInfo.istWarnung 
                    ? 'linear-gradient(90deg, #d97706, #f59e0b)'
                    : 'linear-gradient(90deg, #059669, #10b981)',
                borderRadius: '6px',
                transition: 'width 0.3s ease'
              }} />
            </div>
            <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '6px' }}>
              <span style={{ color: '#64748b', fontSize: '10px' }}>
                {appState.kunden?.length || 0} Kunden â€¢ {appState.material?.length || 0} Positionen â€¢ {rechnungen.length} Dokumente
              </span>
              <span style={{ color: '#64748b', fontSize: '10px' }}>
                {speicherInfo.freiKB} KB frei
              </span>
            </div>
          </div>
          
          <div className="privacy-footer-motto">
            <span className="shield">ğŸ›¡ï¸</span>Wir speichern nichts. Wir sehen nichts.
          </div>
          <p className="privacy-footer-text">
            <strong>Zero-Knowledge-Prinzip:</strong> Ihre Daten werden ausschlieÃŸlich lokal in Ihrem Browser (IndexedDB) gespeichert und Backups mit <strong>AES-256-GCM</strong> verschlÃ¼sselt. Kein Server, keine Cloud, keine Datensammlung â€“ Ihre Rechnungen gehÃ¶ren nur Ihnen.
          </p>
          <div className="privacy-footer-badges">
            <span className="privacy-badge green">âœ“ Lokale Speicherung</span>
            <span className="privacy-badge green">âœ“ Keine Registrierung</span>
            <span className="privacy-badge">ğŸ” MilitÃ¤rgrad-VerschlÃ¼sselung</span>
            <span className="privacy-badge">ğŸ’¾ IndexedDB</span>
            <span className="privacy-badge green">âœ“ DSGVO-konform</span>
          </div>
          <div className="privacy-footer-copyright">
            Â© 2026 Rechnungsprogramm â€“ Professionelle Rechnungserstellung mit maximaler Datensicherheit
          </div>
        </div>
      </div>
      
      {/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       * ACTION BAR - Sticky Bottom (Mobile-First)
       * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */}
      <div className="fixed bottom-0 left-0 right-0 md:left-96 z-40 bg-slate-900/95 backdrop-blur border-t border-slate-700 px-3 py-2 no-print">
        <div className="flex items-center gap-2 max-w-4xl mx-auto overflow-x-auto">
          {/* Dokumenttyp Dropdown */}
          <select
            value={aktivesDok.typ}
            onChange={e => setAktivesDok(prev => ({ ...prev, typ: e.target.value }))}
            className="bg-slate-800 text-white text-xs font-bold px-2 py-2.5 rounded-lg border border-slate-600 flex-shrink-0 w-24 sm:w-auto"
          >
            <option value="RECHNUNG">ğŸ“„ RE</option>
            <option value="ANGEBOT">ğŸ“‹ AN</option>
            <option value="ABSCHLAGSRECHNUNG">ğŸ“‘ AR</option>
            <option value="LEERES_DOKUMENT">ğŸ“ LD</option>
          </select>
          
          {/* Neu Button */}
          <button
            onClick={newDok}
            className="bg-teal-600 hover:bg-teal-500 text-white font-bold px-3 py-2.5 rounded-lg text-xs transition-colors"
            title="Neues Dokument"
          >
            â•
          </button>
          
          {/* Spacer */}
          <div className="flex-1" />
          
          {/* Speichern Button (Blau) */}
          <button
            onClick={() => { saveDok(); forceSave(); }}
            className="bg-blue-600 hover:bg-blue-500 text-white font-bold px-4 py-2.5 rounded-lg text-xs flex items-center gap-1.5 transition-colors"
          >
            <span>ğŸ’¾</span>
            <span className="hidden sm:inline">Speichern</span>
          </button>
          
          {/* Drucken Button (Grau) */}
          <button
            onClick={async () => {
              saveDok();
              const loading = showLoadingDialog('ğŸ–¨ï¸ Bereite Druck vor...');
              
              try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
                
                const berechnungen = { restNetto, nettoNachRabatt, mwst, brutto, abschlagProzent, abschlagBetrag, restBrutto };
                renderPDFContent(doc, aktivesDok, firmenDaten, berechnungen);
                
                const pdfBlobUrl = doc.output('bloburl');
                
                const iframe = document.createElement('iframe');
                iframe.style.cssText = 'position:fixed;top:-9999px;left:-9999px;width:0;height:0;border:none;';
                document.body.appendChild(iframe);
                
                iframe.onload = () => {
                  loading.close();
                  setTimeout(() => {
                    try {
                      iframe.contentWindow.focus();
                      iframe.contentWindow.print();
                    } catch (e) {
                      window.open(pdfBlobUrl, '_blank');
                    }
                    setTimeout(() => {
                      document.body.removeChild(iframe);
                      URL.revokeObjectURL(pdfBlobUrl);
                    }, 5000);
                  }, 500);
                };
                
                iframe.src = pdfBlobUrl;
                
              } catch (err) {
                loading.close();
                alert('Druckfehler: ' + err.message);
              }
            }}
            className="bg-slate-600 hover:bg-slate-500 text-white font-bold px-4 py-2.5 rounded-lg text-xs transition-colors"
            title="Drucken"
          >
            ğŸ–¨ï¸
          </button>
          
          {/* Archiv Button (Lila) */}
          <button
            onClick={async () => {
              saveDok();
              const password = await new Promise(resolve => {
                const pw = prompt('ğŸ”’ Archiv-Passwort eingeben:\n\n(Zum EntschlÃ¼sseln benÃ¶tigt)');
                resolve(pw);
              });
              if (!password) return;
              
              const loading = showLoadingDialog('ğŸ”’ Erstelle verschlÃ¼sseltes Archiv...');
              
              try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
                
                const berechnungen = { restNetto, nettoNachRabatt, mwst, brutto, abschlagProzent, abschlagBetrag, restBrutto };
                renderPDFContent(doc, aktivesDok, firmenDaten, berechnungen);
                
                const pdfArrayBuffer = doc.output('arraybuffer');
                
                const zugferdXML = generateZUGFeRDXML(aktivesDok, firmenDaten);
                const xmlBytes = new TextEncoder().encode(zugferdXML);
                
                const pdfLength = pdfArrayBuffer.byteLength;
                const xmlLength = xmlBytes.length;
                const headerSize = 8;
                const dataSize = headerSize + pdfLength + xmlLength;
                
                const PADDING_BLOCK = 512 * 1024;
                const paddedSize = Math.ceil(dataSize / PADDING_BLOCK) * PADDING_BLOCK;
                
                const combinedBuffer = new ArrayBuffer(paddedSize);
                const view = new DataView(combinedBuffer);
                const bytes = new Uint8Array(combinedBuffer);
                
                view.setUint32(0, pdfLength, true);
                view.setUint32(4, xmlLength, true);
                bytes.set(new Uint8Array(pdfArrayBuffer), headerSize);
                bytes.set(xmlBytes, headerSize + pdfLength);
                
                const paddingStart = headerSize + pdfLength + xmlLength;
                const paddingSize = paddedSize - dataSize;
                for (let i = 0; i < paddingSize; i += 65536) {
                  const chunk = new Uint8Array(Math.min(65536, paddingSize - i));
                  crypto.getRandomValues(chunk);
                  bytes.set(chunk, paddingStart + i);
                }
                
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                const keyMaterial = await crypto.subtle.importKey(
                  'raw', new TextEncoder().encode(password), 'PBKDF2', false, ['deriveBits', 'deriveKey']
                );
                
                const key = await crypto.subtle.deriveKey(
                  { name: 'PBKDF2', salt, iterations: 310000, hash: 'SHA-256' },
                  keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt']
                );
                
                const encrypted = await crypto.subtle.encrypt(
                  { name: 'AES-GCM', iv, tagLength: 128 }, key, combinedBuffer
                );
                
                const finalBuffer = new ArrayBuffer(28 + encrypted.byteLength);
                const finalBytes = new Uint8Array(finalBuffer);
                finalBytes.set(salt, 0);
                finalBytes.set(iv, 16);
                finalBytes.set(new Uint8Array(encrypted), 28);
                
                const fullName = aktivesDok.kunde?.name || 'Unbekannt';
                const cleanName = fullName.replace(/^(Herr|Herrn|Frau|FrÃ¤ulein)\s+/i, '').trim();
                const lastName = cleanName.split(' ').pop().replace(/[^a-zA-Z0-9Ã¤Ã¶Ã¼ÃŸ-]/g, '');
                const filename = `${aktivesDok.nummer || 'archiv'}-${lastName}.dat`;
                
                const blob = new Blob([finalBuffer], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                loading.close();
                alert(`âœ… Archiv erstellt!\n\nğŸ“¦ ${filename}\nğŸ“Š ${Math.round(finalBuffer.byteLength / 1024)} KB\nğŸ” AES-256-GCM`);
                
              } catch (err) {
                loading.close();
                alert('Fehler: ' + err.message);
              }
            }}
            className="bg-purple-700 hover:bg-purple-600 text-white font-bold px-4 py-2.5 rounded-lg text-xs transition-colors"
            title="Archivieren"
          >
            ğŸ”’
          </button>
          
          {/* E-Rechnung Button (Indigo) - Nur bei Rechnungen und Abschlagsrechnungen sichtbar */}
          {['RECHNUNG', 'ABSCHLAGSRECHNUNG'].includes(aktivesDok.typ) && (
            <button
              onClick={async () => {
                saveDok();
                const loading = showLoadingDialog('ğŸ“„ Generiere E-Rechnung...');
                
                try {
                  const { jsPDF } = window.jspdf;
                  const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
                  
                  const berechnungen = { restNetto, nettoNachRabatt, mwst, brutto, abschlagProzent, abschlagBetrag, restBrutto };
                  renderPDFContent(doc, aktivesDok, firmenDaten, berechnungen);
                  
                  const zugferdXML = generateZUGFeRDXML(aktivesDok, firmenDaten);
                  
                  const fullName = aktivesDok.kunde?.name || 'Unbekannt';
                  const cleanName = fullName.replace(/^(Herr|Herrn|Frau|FrÃ¤ulein)\s+/i, '').trim();
                  const lastName = cleanName.split(' ').pop().replace(/[^a-zA-Z0-9Ã¤Ã¶Ã¼ÃŸ-]/g, '');
                  const baseName = `${aktivesDok.nummer || 'ENTWURF'}-${lastName}`;
                  
                  doc.save(`${baseName}_ZUGFeRD.pdf`);
                  
                  setTimeout(() => {
                    const xmlBlob = new Blob([zugferdXML], { type: 'application/xml' });
                    const xmlUrl = URL.createObjectURL(xmlBlob);
                    const xmlLink = document.createElement('a');
                    xmlLink.href = xmlUrl;
                    xmlLink.download = `${baseName}_factur-x.xml`;
                    xmlLink.click();
                    URL.revokeObjectURL(xmlUrl);
                  }, 500);
                  
                  loading.close();
                  alert(`âœ… E-Rechnung erstellt!\n\nğŸ“„ ${baseName}_ZUGFeRD.pdf\nğŸ“‹ ${baseName}_factur-x.xml`);
                  
                } catch (err) {
                  loading.close();
                  alert('Fehler: ' + err.message);
                }
              }}
              className="bg-amber-600 hover:bg-amber-500 text-white font-bold px-4 py-2.5 rounded-lg text-xs flex items-center gap-1.5 transition-colors"
              title="E-Rechnung (ZUGFeRD)"
            >
              <span>ğŸ“‹</span>
              <span className="hidden sm:inline">ZUGFeRD</span>
            </button>
          )}
          
          {/* PDF Button (GrÃ¼n) */}
          <button
            onClick={createPDF}
            className="bg-emerald-600 hover:bg-emerald-500 text-white font-bold px-4 py-2.5 rounded-lg text-xs flex items-center gap-1.5 transition-colors"
            title="PDF erstellen"
          >
            <span>ğŸ“„</span>
            <span className="hidden sm:inline">PDF</span>
          </button>
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// APP WRAPPER MIT VAULT AUTHENTICATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function App() {
  return (
    <VaultProvider>
      <VaultApp />
    </VaultProvider>
  );
}

function VaultApp() {
  const { isUnlocked, isLoading } = useVault();
  
  if (isLoading) {
    return (
      <div style={{
        position: 'fixed',
        top: 0, left: 0, right: 0, bottom: 0,
        background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        flexDirection: 'column',
        color: 'white'
      }}>
        <div style={{ fontSize: '60px', marginBottom: '20px', animation: 'pulse 2s infinite' }}>ğŸ”</div>
        <h1 style={{ fontSize: '20px', color: '#94a3b8' }}>Lade Secure Vault...</h1>
      </div>
    );
  }
  
  if (!isUnlocked) {
    return <LoginScreen />;
  }
  
  return <MainApp />;
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
</script>
</body>
</html>
